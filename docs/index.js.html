<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Trilogy.html">Trilogy</a><ul class='methods'><li data-type='method'><a href="Trilogy.html#count">count</a></li><li data-type='method'><a href="Trilogy.html#createTable">createTable</a></li><li data-type='method'><a href="Trilogy.html#decrement">decrement</a></li><li data-type='method'><a href="Trilogy.html#del">del</a></li><li data-type='method'><a href="Trilogy.html#exec">exec</a></li><li data-type='method'><a href="Trilogy.html#first">first</a></li><li data-type='method'><a href="Trilogy.html#getQueryBuilder">getQueryBuilder</a></li><li data-type='method'><a href="Trilogy.html#getSchemaBuilder">getSchemaBuilder</a></li><li data-type='method'><a href="Trilogy.html#getValue">getValue</a></li><li data-type='method'><a href="Trilogy.html#hasTable">hasTable</a></li><li data-type='method'><a href="Trilogy.html#increment">increment</a></li><li data-type='method'><a href="Trilogy.html#insert">insert</a></li><li data-type='method'><a href="Trilogy.html#raw">raw</a></li><li data-type='method'><a href="Trilogy.html#run">run</a></li><li data-type='method'><a href="Trilogy.html#select">select</a></li><li data-type='method'><a href="Trilogy.html#update">update</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* @flow */

import jetpack from 'fs-jetpack'
import Promise from 'bluebird'
import knex from 'knex'
import SQL from 'sql.js'
import _ from 'lodash'

export default class Trilogy {
  fileName: string;
  db: any;
  verbose: Function;
  errorListener: Function | null;
  knex: any;
  sb: any;

  /**
   * Initialize a new datastore instance, creating an SQLite database
   * file at the `fileName` path if it does not yet exist, or reading
   * it if it does.
   *
   * @param {string} fileName
   *  Either a path to an existing database or the path at which one
   *  should be created.
   * @param {Object} [opts={}]
   * @param {Function} [opts.verbose]
   *  A function that will receive every query run against the database
   * @param {Function} [opts.errorListener]
   *  A function that receives any errors thrown during query execution
   * @throws if `fileName` is not provided
   *
   * @example
   *
   * import Trilogy from 'trilogy'
   *
   * const db = new Trilogy('./storage.db')
   *
   * // WITH OPTIONS:
   * // verbose function
   * const db = new Trilogy('./storage.db', {
   *   verbose: console.log.bind(console)
   * })
   *
   * // errorListener function
   * function errorHandler (err) {
   *   if (err.message === `Trilogy#createTable :: 'columns' must be an array`) {
   *     console.log('Crap. Should have read the docs!')
   *   }
   * }
   *
   * const db = new Trilogy('./storage.db', {
   *   errorListener: errorHandler
   * })
   */
  constructor (
    fileName: string,
    opts: ClassOptions = {
      verbose: () => {},
      errorListener: null
    }
  ) {
    if (!fileName) throw new Error('Trilogy constructor must be provided a file path.')

    Object.assign(this, {
      fileName,
      db: null,
      verbose: _.isFunction(opts.verbose)
        ? opts.verbose
        : () => {},
      errorListener: _.isFunction(opts.errorListener)
        ? opts.errorListener
        : null
    })

    this._init()
  }

  /**
   * Initialize the instance and create or access the database file
   * @private
   */
  _init () {
    if (jetpack.exists(this.fileName)) {
      const file = jetpack.read(this.fileName, 'buffer')
      this.db = new SQL.Database(file)
    } else {
      this.db = new SQL.Database()
      this._write()
    }

    this.knex = knex({ client: 'sqlite', useNullAsDefault: true })

    this.sb = this.knex.schema
  }

  /**
   * Export the data in memory to the database file
   * @private
   */
  _write () {
    if (!this.db) {
      this._errorHandler('Could not write - no database initiated')
    }

    try {
      const data = this.db.export()
      const buffer = new Buffer(data)

      jetpack.file(this.fileName, {
        content: buffer, mode: '777'
      })
    } catch (e) {
      this._errorHandler(e)
    }
  }

  /**
   * Execute a query on the database, ignoring its results
   * @param {(Object|string)} query - any SQLite query string
   * @returns {Promise&lt;(boolean|Error)>} `true` if the query ran successfully, else an error
   *
   * @see {@link exec} if you need a return value
   */
  async run (query: Object | string): Promise&lt;?Error> {
    if (!this.db) {
      return this._errorHandler('Could not write - no database initiated')
    }

    if (!_.isString(query)) query = query.toString()
    this.verbose(query)

    return new Promise((resolve: Function, reject: Function): Promise => {
      try {
        this.db.run(query)
        this._write()
        return resolve(true)
      } catch (e) {
        return reject(e)
      }
    })
  }

  /**
   * Execute a query on the database and return its results
   * @param {(Object|string)} query - any SQLite query string
   * @returns {Promise&lt;(Array|Error)>}
   *  an `Array` containing query results, or an `Error` if one occurred
   *
   * @see {@link run} if you don't care about a return value
   */
  async exec (query: Object | string): Promise&lt;Array&lt;Object> | Error> {
    if (!this.db) {
      return this._errorHandler('Could not write - no database initiated')
    }

    if (!_.isString(query)) query = query.toString()
    this.verbose(query)

    return new Promise((resolve: Function, reject: Function): Promise => {
      try {
        const val = this.db.exec(query)
        return resolve(val)
      } catch (e) {
        return reject(e)
      }
    })
  }

  /**
   * Add a table to the database
   * @param {string} tableName
   * @param {Object[]} columns
   * @param {Object} [options]
   * @returns {Promise}
   */
  async createTable (
    tableName: string,
    columns: Array&lt;Object>,
    options: Object = {}
  ): Promise&lt;void> {
    if (!Array.isArray(columns) || !columns.length) {
      return this._errorHandler('#createTable', `'columns' must be an array`)
    }

    const query = this.sb.createTableIfNotExists(tableName, table => {
      _.map(columns, column => {
        if (_.isPlainObject(column)) {
          if (!column.name) return
          if (!column.type || !(column.type in table)) column.type = 'text'
          let partial = table[column.type](column.name)

          _.map(column, (attr, prop) => {
            // name &amp; type are handled above
            if (prop === 'name' || prop === 'type') return
            if (!(prop in partial)) return

            // handle methods that take no arguments
            switch (prop) {
              case 'primary':
              case 'notNull':
              case 'notNullable':
              case 'nullable':
              case 'unsigned':
                partial = partial[prop]()
                break
              default:
                partial = partial[prop](attr)
            }
          })
        } else if (_.isString(column)) {
          table.text(column)
        }
      })

      if ('compositeKey' in options) {
        table.primary(options.compositeKey)
      }
    })

    try {
      await this.run(query)
      return Promise.resolve()
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  async createTableCallback (tableName: string, cb: Function): Promise {
    if (!_.isFunction(cb)) {
      return this._errorHandler('#createTableCallback', `2nd parameter must be a function`)
    }

    const query = this.sb.createTableIfNotExists(tableName, cb)

    try {
      await this.run(query)
      return Promise.resolve()
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Check if a table exists in the database
   * @param {string} tableName
   * @returns {Promise&lt;boolean>}
   */
  async hasTable (
    tableName: string
  ): Promise&lt;boolean> {
    try {
      const res = await this.count('sqlite_master', 'name', {
        name: tableName
      })

      return Promise.resolve(res > 0)
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Insert values into a table in the database
   * @param {string} tableName
   * @param {Object} values
   * @param {Object} [options={}]
   * @returns {Promise&lt;number>} The number of rows inserted
   */
  async insert (
    tableName: string,
    values: Object,
    options?: { conflict?: string } = {}
  ): Promise&lt;number> {
    if (!tableName || !_.isString(tableName)) {
      return this._errorHandler('#insert', `'tableName' must be a string`)
    }

    let query = this.knex.table(tableName).insert(values)

    // Knex doesn't have support for conflict clauses yet :(
    if (options.conflict) {
      const str = Trilogy._getConflictString(options.conflict)
      query = query.toString().replace('insert into', `insert${str}into`)
    }

    try {
      await this.run(query)
      return Promise.resolve(this.db.getRowsModified())
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Execute a select query on the database
   * @param {string} tableName
   * @param {(string|Array)} [columns=['*']]
   * @param {(Object|Array|Function)} [where]
   * @param {Object} [options={}]
   * @returns {Promise&lt;Array>}
   */
  async select (
    tableName: string,
    columns?: string | Array&lt;string> = ['*'],
    where?: WhereClause = ['1', '=', '1'],
    options?: { random?: boolean; order?: string | Array&lt;string> } = {}
  ): Promise&lt;Array&lt;Object>> {
    if (!tableName || !_.isString(tableName)) {
      return this._errorHandler('#select', `'tableName' must be a string`)
    }

    if (arguments.length === 2 &amp;&amp; _.isPlainObject(columns)) {
      // assuming `columns` is actually an options object
      options = columns
      columns = ['*']
    }

    if (!Trilogy._isValidWhere(where)) {
      return this._errorHandler('#select', `'where' argument is invalid`)
    }

    columns = Trilogy._sanitizeColumns(columns)

    const partial = this.knex.column(columns).table(tableName)
    let query = Trilogy._sanitizeWhere(where, partial)

    if (options.random) {
      query = query.orderByRaw('RANDOM()')
    } else if (options.order) {
      query = Trilogy._sanitizeOrder(options.order, partial)
    }

    try {
      const result = await this.exec(query)
      const res = Trilogy._parseResponse(result)
      return Promise.resolve(res)
    } catch (e) {
      if (e.message.endsWith('of undefined')) {
        // the value probably just doesn't exist
        // resolve to undefined rather than reject
        return Promise.resolve(undefined)
      }
      return this._errorHandler(e)
    }
  }

  /**
   * Select the first row returned by the query
   * @param {string} tableName
   * @param {(string|Array)} [columns=['*']]
   * @param {(Object|Array|Function)} [where]
   * @param {Object} [options={}]
   * @returns {Promise&lt;Object>}
   */
  async first (
    tableName: string,
    columns?: string | Array&lt;string> = ['*'],
    where?: WhereClause = ['1', '=', '1'],
    options?: { random?: boolean } = {}
  ): Promise&lt;Object> {
    if (!tableName || !_.isString(tableName)) {
      return this._errorHandler('#first', `'tableName' must be a string`)
    }

    if (arguments.length === 2 &amp;&amp; _.isPlainObject(columns)) {
      // assuming `columns` is actually an options object
      options = columns
      columns = ['*']
    }

    if (!Trilogy._isValidWhere(where)) {
      return this._errorHandler('#first', `'where' argument is invalid`)
    }

    columns = Trilogy._sanitizeColumns(columns)

    const partial = this.knex.table(tableName).first(columns)
    let query = Trilogy._sanitizeWhere(where, partial)

    if (options.random) {
      query = query.orderByRaw('RANDOM()')
    }

    try {
      const result = await this.exec(query)
      const res = Trilogy._parseResponse(result)
      return Promise.resolve(res[0])
    } catch (e) {
      if (e.message.endsWith('of undefined')) {
        // the value probably just doesn't exist
        // resolve to undefined rather than reject
        return Promise.resolve(undefined)
      }
      return this._errorHandler(e)
    }
  }

  /**
   * Retrieve the value at a specific row in a specific column
   * @param {string} tableName
   * @param {string} column
   * @param {(Object|Array|Function)} [where]
   * @returns {Promise&lt;*>}
   */
  async getValue (
    tableName: string,
    column: string,
    where?: WhereClause = ['1', '=', '1']
  ): Promise&lt;any> {
    if (!tableName || !_.isString(tableName)) {
      return this._errorHandler('#getValue', `'tableName' must be a string`)
    }

    if (!column || !_.isString(column) || column.includes(',')) {
      return this._errorHandler('#getValue', `'column' must be a single column name as a string`)
    }

    if (!Trilogy._isValidWhere(where)) {
      console.log(where)
      return this._errorHandler('#getValue', `'where' argument is invalid`)
    }

    const partial = this.knex.table(tableName).first(column)
    const query = Trilogy._sanitizeWhere(where, partial)

    try {
      const result = await this.exec(query)
      const res = Trilogy._parseResponse(result)
      return Promise.resolve(res[0][column])
    } catch (e) {
      if (e.message.endsWith('of undefined')) {
        // the value probably just doesn't exist
        // resolve to undefined rather than reject
        return Promise.resolve(undefined)
      }
      return this._errorHandler(e)
    }
  }

  /**
   * Update rows in the database
   * @param {string} tableName
   * @param {(Object|Array)} values
   * @param {(Object|Array|Function)} [where]
   * @param {Object} [options={}]
   * @returns {Promise&lt;Number>} The number of rows affected
   */
  async update (
    tableName: string,
    values: ?Object | Array&lt;*>,
    where?: WhereClause = ['1', '=', '1'],
    options?: { conflict?: string } = {}
  ): Promise&lt;number> {
    if (!tableName || !_.isString(tableName)) {
      return this._errorHandler('#update', `'tableName' must be a string`)
    }

    if (!_.isPlainObject(values) &amp;&amp; (!Array.isArray(values) || values.length !== 2)) {
      return this._errorHandler('#update', `'values' must be either an object or key / value array`)
    }

    if (!Trilogy._isValidWhere(where)) {
      return this._errorHandler('#update', `'where' argument is invalid`)
    }

    const partial = this.knex.table(tableName)
    const update = _.isPlainObject(values) ? partial.update(values) : partial.update(...values)
    let query = Trilogy._sanitizeWhere(where, update)

    // Knex doesn't have support for conflict clauses yet :(
    if (options.conflict) {
      const str = Trilogy._getConflictString(options.conflict)
      query = query.toString().replace('update', `update${str}`)
    }

    try {
      await this.run(query)
      return Promise.resolve(this.db.getRowsModified())
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Increment a value at `column` by a specified `amount`
   * @param {string} tableName
   * @param {string} column
   * @param {number} [amount=1]
   * @param {(Object|Array|Function)} [where]
   * @returns {Promise}
   */
  async increment (
    tableName: string,
    column: string,
    amount?: number = 1,
    where?: WhereClause = ['1', '=', '1']
  ): Promise&lt;void> {
    if (!tableName || !_.isString(tableName)) {
      return this._errorHandler('#increment', `'tableName' must be a string`)
    }

    if (arguments.length &lt; 2) {
      return this._errorHandler('#increment', `invalid number of arguments`)
    }

    if (amount &amp;&amp; !_.isInteger(amount)) {
      where = amount
      amount = 1
    }

    if (!Trilogy._isValidWhere(where)) {
      return this._errorHandler('#increment', `'where' argument is invalid`)
    }

    const partial = this.knex.table(tableName).increment(column, amount)
    const query = Trilogy._sanitizeWhere(where, partial)

    try {
      await this.run(query)
      return Promise.resolve()
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Decrement a value at `column` by a specified `amount`
   * @param {Object} params
   * @param {...*} args
   *
   * @example
   *
   * db.decrement({
   *   at: 'people',
   *   in: 'age',
   *   by: 2,
   *   allowNegative: false,
   *   where: { name: 'Me' }
   * })
   *
   * db.decrement({ at: 'people.age', by: 4, where: { name: 'Me' })
   */
  async decrement (
    params: {
      at: string;
      col?: string;
      by?: number;
      where?: WhereClause;
      allowNegative?: boolean;
    } = {},
    ...args: Array&lt;any>
  ): Promise&lt;void> {
    if (args.length || !_.isPlainObject(params)) {
      return this._decrement(params, ...args)
    }

    if (!Object.keys(params).length) {
      return this._errorHandler('#decrement', 'invalid arguments')
    }

    const opt = Object.assign({
      by: 1,
      allowNegative: false,
      where: ['1', '=', '1']
    }, params)

    if (!Trilogy._isValidWhere(params.where)) {
      return this._errorHandler('#decrement', `'where' argument is invalid`)
    }

    const [tbl, col] = Trilogy._parseTablePath(opt.at, opt.col)

    const partial = this.knex.table(tbl)
    const rawStr = opt.allowNegative
      ? `${col} - ${opt.by}`
      : `MAX(0, ${col} - ${opt.by})`
    const updated = partial.update({ [col]: this.knex.raw(rawStr) })
    const query = Trilogy._sanitizeWhere(opt.where, updated)

    try {
      await this.run(query)
      return Promise.resolve()
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Decrement a value at `column` by a specified `amount`
   * @param {string} tableName
   * @param {string} column
   * @param {(Object|Array|Function)} [where=['1', '=', '1']]
   * @returns {Promise}
   * @private
   */
  async _decrement (
    tableName: string,
    column: string,
    where?: WhereClause = ['1', '=', '1']
  ): Promise&lt;void> {
    if (!_.isString(tableName)) {
      return this._errorHandler('#decrement', `'tableName' must be a string`)
    }

    if (!_.isString(column)) {
      where = column
      ;[tableName, column] = Trilogy._parseTablePath(tableName, column)
      if (!column) return this._errorHandler('#decrement', `'column' must be a string`)
    }

    if (arguments.length &lt; 2) {
      return this._errorHandler('#decrement', `invalid number of arguments`)
    }

    if (!Trilogy._isValidWhere(where)) {
      return this._errorHandler('#decrement', `'where' argument is invalid`)
    }

    const partial = this.knex.table(tableName)
    const rawStr = `MAX(0, ${column} - 1)`
    const updated = partial.update({ [column]: this.knex.raw(rawStr) })
    const query = Trilogy._sanitizeWhere(where, updated)

    try {
      await this.run(query)
      return Promise.resolve()
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Delete rows from a table
   * @param {string} tableName
   * @param {(Object|Array|Function)} [where]
   * @returns {Promise&lt;number>} The number of rows deleted
   */
  async del (
    tableName: string,
    where?: WhereClause = ['1', '=', '1']
  ): Promise&lt;number> {
    if (!tableName || !_.isString(tableName)) {
      return this._errorHandler('#del', `'tableName' must be a string`)
    }

    if (!Trilogy._isValidWhere(where)) {
      return this._errorHandler('#del', `'where' argument is invalid`)
    }

    const partial = this.knex.table(tableName).del()
    const query = Trilogy._sanitizeWhere(where, partial)

    try {
      await this.run(query)
      return Promise.resolve(this.db.getRowsModified())
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Select the first row returned by the query
   * @param {string} tableName
   * @param {String} [column='*']
   * @param {(Object|Array|Function)} [where]
   * @param {Object} [options={}]
   * @returns {Promise&lt;number>} The number of rows (meeting criteria if supplied)
   */
  async count (
    tableName: string,
    column?: string = '*',
    where?: WhereClause = ['1', '=', '1'],
    options?: Object = {}
  ): Promise&lt;number> {
    if (!tableName || !_.isString(tableName)) {
      return this._errorHandler('#count', `'tableName' must be a string`)
    }

    if (arguments.length === 2 &amp;&amp; _.isPlainObject(column)) {
      // assuming `column` is actually an options object
      options = column
      column = '*'
    }

    if (!_.isString(column)) {
      return this._errorHandler('#count', `'column' must be a string`)
    }

    if (!Trilogy._isValidWhere(where)) {
      return this._errorHandler('#count', `'where' argument is invalid`)
    }

    let partial
    if (options.distinct) {
      partial = this.knex.table(tableName).countDistinct(`${column} as count`)
    } else {
      partial = this.knex.table(tableName).count(`${column} as count`)
    }

    const query = Trilogy._sanitizeWhere(where, partial).toString()

    try {
      const statement = this.db.prepare(query)
      const res = statement.getAsObject({})
      if (_.isPlainObject(res) &amp;&amp; 'count' in res) {
        return Promise.resolve(res.count)
      } else {
        return Promise.resolve(0)
      }
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Execute arbitrary SQLite queries
   * @param {string} query
   * @param {boolean} ret - whether to return the result
   * @returns {Promise&lt;(Object|undefined)>}
   */
  async raw (
    query: string,
    ret?: boolean = false
  ): Promise&lt;Object | void> {
    try {
      const done = ret ? await this.exec(query) : await this.run(query)
      return Promise.resolve(ret ? done : undefined)
    } catch (e) {
      return this._errorHandler(e)
    }
  }

  /**
   * Exposes the Knex schema builder object
   * @returns {Object}
   *
   * @see {@link raw} to run queries built with this
   */
  getSchemaBuilder (): Object {
    /**
     * @prop sb
     * @type {Object}
     * @memberOf this
     */
    return this.sb
  }

  /**
   * Exposes the Knex query builder object
   * @returns {Object}
   *
   * @see {@link raw} to run queries built with this
   */
  getQueryBuilder (): Object {
    return this.knex
  }

  /**
   * Build an 'on conflict' clause query component
   * @param {string} conflict - the type of query to build
   * @returns {string} query component
   * @static
   * @private
   */
  static _getConflictString (conflict: string): string {
    switch (conflict.toLowerCase()) {
      case 'fail': return ' or fail '
      case 'abort': return ' or abort '
      case 'ignore': return ' or ignore '
      case 'replace': return ' or replace '
      case 'rollback': return ' or rollback '
      default: return ' '
    }
  }

  /**
   * Parse an sql.js return value into a sane JS array
   * @param {Array} contents
   * @returns {Array}
   * @static
   * @private
   */
  static _parseResponse (contents: Array&lt;Array&lt;Object>>): Array&lt;Object> {
    if (contents.length) {
      const columns = contents[0].columns
      const values = contents[0].values
      const results = []
      for (let i = 0; i &lt; values.length; i++) {
        let line = {}
        for (let j = 0; j &lt; columns.length; j++) {
          line[columns[j]] = values[i][j]
        }
        results.push(line)
      }
      return results
    } else {
      return []
    }
  }

  /**
   * Check that a where argument is a valid type
   * Valid types are: Object | Array | Function
   * @param {*} where
   * @returns {boolean}
   * @static
   * @private
   */
  static _isValidWhere (where: any): boolean {
    if (_.isPlainObject(where)) return true

    if (Array.isArray(where)) {
      const len = where.length
      return len === 2 || len === 3
    }

    return _.isFunction(where)
  }

  /**
   * Normalize a columns argument to an Array
   * Returns ['*'] if the input is not a string or Array
   * This means it defaults to 'all columns'
   * @param {*} columns
   * @returns {Array}
   * @static
   * @private
   */
  static _sanitizeColumns (
    columns: string | Array&lt;string>
  ): Array&lt;any> {
    if (Array.isArray(columns)) return columns
    if (_.isString(columns)) return [columns]
    return ['*']
  }

  /**
   * Complete a where query component based on type
   * Arrays are spread into arguments
   * Functions get bound to the knex instance
   * Objects are passed along as is
   * @param {(Object|Array|Function)} where
   * @param {Object} partial - the current knex query chain
   * @returns {Object} a continued knex query chain
   * @static
   * @private
   */
  static _sanitizeWhere (where: WhereClause, partial: Object): Object {
    if (Array.isArray(where)) {
      return partial.where(...where)
    } else if (_.isFunction(where)) {
      return partial.where(where.bind(partial))
    } else {
      // it's an object
      return partial.where(where)
    }
  }

  /**
   * Complete an 'order by' query component
   * Arrays are spread into arguments
   * Strings are passed along as is
   * @param {(Array|string)} order
   * @param {Object} partial - the current knex query chain
   * @returns {Object} a continued knex query chain
   * @private
   */
  static _sanitizeOrder (
    order: Array&lt;any> | string,
    partial: Object
  ): Object {
    if (Array.isArray(order) &amp;&amp; order.length === 2) {
      return partial.orderBy(...order)
    } else if (_.isString(order)) {
      return partial.orderBy(order)
    } else {
      return partial
    }
  }

  /**
   * Parse a dot-notated path into table, column, &amp; row
   * @param {string} table
   * @param {string} column
   * @param {string} row
   * @returns {Array&lt;string>}
   * @private
   */
  static _parseTablePath (
    table: string,
    column: ?string,
    row: ?string
  ): Array&lt;?string> {
    if (table.includes('.')) {
      const [top, inner, nested] = table.split('.')
      return Trilogy._parseTablePath(top, inner, nested)
    } else if (table.includes('[')) {
      const opener = table.indexOf('[')
      const closer = table.indexOf(']', opener)

      const top = table.substr(0, opener)
      const inner = table.slice(opener + 1, closer)

      const rowIndex = top.length + inner.length + 2

      let extra, nested
      if (rowIndex &lt; table.length) {
        extra = table.slice(rowIndex + 1)
        const rowCloser = extra.indexOf(']')
        nested = extra.substr(0, rowCloser)
      }

      return Trilogy._parseTablePath(top, inner, nested)
    } else {
      return [table, column, row]
    }
  }

  /**
   * Normalize errors to `Error` objects
   * If `err` is a string, it is used as the method path, with `msg` as the message
   * @param {(string|Error)} err
   * @param {string} [msg]
   * @returns {Promise&lt;Error>} a rejected promise with the `Error` object
   * @private
   */
  _errorHandler (
    err: string | Error,
    msg?: string = 'something went horribly wrong'
  ): Promise&lt;?Error> {
    let e = err
    if (_.isString(err)) {
      if (arguments.length === 1) {
        e = new Error(`Trilogy :: ${err}`)
      } else {
        e = new Error(`Trilogy${err} :: ${msg}`)
      }
    }

    if (this.errorListener) {
      this.errorListener(e)
    } else {
      return Promise.reject(e)
    }
  }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sun Aug 07 2016 23:51:08 GMT-0500 (Central Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
