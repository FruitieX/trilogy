{"version":3,"file":null,"sources":["../lib/constants.js","../lib/index.js"],"sourcesContent":["export default {\r\n  ERR_UNKNOWN:\r\n    `an unknown error occurred. Check the stacktrace or report an\r\n     issue if there is a problem with trilogy itself.`,\r\n  ERR_COL_MISSING:\r\n    `column name is required. Pass it as an independent argument\r\n     or as dot-notation along with the table argument.`,\r\n  ERR_NO_DATABASE: `Could not write - no database initialized.`\r\n}\r\n","/* @flow */\r\n\r\nimport jetpack from 'fs-jetpack'\r\nimport arify from 'arify'\r\nimport Promise from 'bluebird'\r\nimport knex from 'knex'\r\nimport SQL from 'sql.js'\r\nimport _ from 'lodash'\r\n\r\nimport constants from './constants'\r\n\r\nexport default class Trilogy {\r\n  fileName: string;\r\n  verbose: Function;\r\n  errorListener: Function | null;\r\n  knex: any;\r\n  db: any;\r\n  sb: any;\r\n\r\n  /**\r\n   * Initialize a new datastore instance, creating an SQLite database\r\n   * file at the `fileName` path if it does not yet exist, or reading\r\n   * it if it does.\r\n   *\r\n   * @param {string} fileName\r\n   *  Either a path to an existing database or the path at which one\r\n   *  should be created.\r\n   * @param {Object} [opts={}]\r\n   * @param {Function} [opts.verbose]\r\n   *  A function that will receive every query run against the database\r\n   * @param {Function} [opts.errorListener]\r\n   *  A function that receives any errors thrown during query execution\r\n   * @throws if `fileName` is not provided\r\n   *\r\n   * @example\r\n   *\r\n   * import Trilogy from 'trilogy'\r\n   *\r\n   * const db = new Trilogy('./storage.db')\r\n   *\r\n   * // WITH OPTIONS:\r\n   * // verbose function\r\n   * const db = new Trilogy('./storage.db', {\r\n   *   verbose: console.log.bind(console)\r\n   * })\r\n   *\r\n   * // errorListener function\r\n   * function errorHandler (err) {\r\n   *   if (err.message === `Trilogy#createTable :: 'columns' must be an array`) {\r\n   *     console.log('Crap. Should have read the docs!')\r\n   *   }\r\n   * }\r\n   *\r\n   * const db = new Trilogy('./storage.db', {\r\n   *   errorListener: errorHandler\r\n   * })\r\n   */\r\n  constructor (\r\n    fileName: string,\r\n    opts?: ClassOptions = {\r\n      verbose: () => {},\r\n      errorListener: null\r\n    }\r\n  ) {\r\n    if (!fileName) throw new Error('Trilogy constructor must be provided a file path.')\r\n\r\n    Object.assign(this, {\r\n      fileName,\r\n      db: null,\r\n      verbose: _.isFunction(opts.verbose)\r\n        ? opts.verbose\r\n        : () => {},\r\n      errorListener: _.isFunction(opts.errorListener)\r\n        ? opts.errorListener\r\n        : null\r\n    })\r\n\r\n    this._init()\r\n  }\r\n\r\n  /**\r\n   * Initialize the instance and create or access the database file\r\n   * @private\r\n   */\r\n  _init () {\r\n    if (jetpack.exists(this.fileName)) {\r\n      const file = jetpack.read(this.fileName, 'buffer')\r\n      this.db = new SQL.Database(file)\r\n    } else {\r\n      this.db = new SQL.Database()\r\n      this._write()\r\n    }\r\n\r\n    this.knex = knex({ client: 'sqlite', useNullAsDefault: true })\r\n\r\n    this.sb = this.knex.schema\r\n  }\r\n\r\n  /**\r\n   * Export the data in memory to the database file\r\n   * @private\r\n   */\r\n  _write () {\r\n    if (!this.db) {\r\n      this._errorHandler(constants.ERR_NO_DATABASE)\r\n    }\r\n\r\n    try {\r\n      const data = this.db.export()\r\n      const buffer = new Buffer(data)\r\n\r\n      jetpack.file(this.fileName, {\r\n        content: buffer, mode: '777'\r\n      })\r\n    } catch (e) {\r\n      this._errorHandler(e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute a query on the database, ignoring its results.\r\n   *\r\n   * @param {(Object|string)} query\r\n   *  Any SQLite query string. If an Object is provided, a `toString`\r\n   *  conversion will be attempted in the case it's a knex query object.\r\n   * @returns {Promise}\r\n   *\r\n   * @see {@link Trilogy#exec} if you need a return value\r\n   */\r\n  async run (query: Object | string): Promise<void> {\r\n    if (!this.db) {\r\n      return this._errorHandler(constants.ERR_NO_DATABASE)\r\n    }\r\n\r\n    if (!_.isString(query)) query = query.toString()\r\n    this.verbose(query)\r\n\r\n    return new Promise((resolve: Function, reject: Function): Promise => {\r\n      try {\r\n        this.db.run(query)\r\n        this._write()\r\n        return resolve()\r\n      } catch (e) {\r\n        return reject(e)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Execute a query on the database and return its results.\r\n   *\r\n   * @param {(Object|string)} query\r\n   *  Any SQLite query string. If an Object is provided, a `toString`\r\n   *  conversion will be attempted in the case it's a knex query object.\r\n   * @returns {Promise<Array>} an `Array` containing query result objects\r\n   *\r\n   * @see {@link Trilogy#run} if you don't care about a return value\r\n   */\r\n  async exec (query: Object | string): Promise<Array<Object>> {\r\n    if (!this.db) {\r\n      return this._errorHandler(constants.ERR_NO_DATABASE)\r\n    }\r\n\r\n    if (!_.isString(query)) query = query.toString()\r\n    this.verbose(query)\r\n\r\n    return new Promise((resolve: Function, reject: Function): Promise => {\r\n      try {\r\n        const val = this.db.exec(query)\r\n        return resolve(val)\r\n      } catch (e) {\r\n        return reject(e)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Add a table to the database. The `columns` argument must be an array of\r\n   * either strings or Objects, which can be mixed and matched. String values\r\n   * default to a column of the SQLite 'text' type. If another type is needed\r\n   * or any other attributes, use an Object.\r\n   *\r\n   * All the properties of the supplied column Object are passed to knex. Some\r\n   * attributes require no values, such as `primary` or `nullable`. In these\r\n   * cases, their presence in the object is enough to add that flag.\r\n   *\r\n   * If the column property is not present in knex's methods it will be ignored.\r\n   * See <a href=\"http://knexjs.org/#Schema-Building\">knex's documentation</a>\r\n   * on Schema Building for the available attributes when creating column tables.\r\n   *\r\n   * @param {string} tableName\r\n   * @param {Object[]} columns\r\n   * @param {Object} [options={}]\r\n   * @param {string[]} [options.compositeKey]\r\n   *  An array of column names as strings. A composite primary key will be\r\n   *  created on all of these columns.\r\n   * @returns {Promise}\r\n   *\r\n   * @example\r\n   *\r\n   * // `columns` should be an Array\r\n   * // each item in the Array should be either a string or an Object\r\n   *\r\n   * // a string in the Array defaults to a text column in the table\r\n   * db.createTable('people', ['email'])\r\n   *\r\n   * // use an object to specify other attributes\r\n   * db.createTable('people', [\r\n   *   { name: 'age', type: 'integer' }\r\n   * ])\r\n   *\r\n   * // you can mix and match\r\n   * db.createTable('people', [\r\n   *   'name',\r\n   *   { name: 'age', type: 'integer' },\r\n   *   'email',\r\n   *   // note that the value of `primary` doesn't make a difference\r\n   *   // this would still be a primary key column\r\n   *   { name: '', primary: false }\r\n   * ])\r\n   */\r\n  async createTable (\r\n    tableName: string,\r\n    columns: Array<Object>,\r\n    options: Object = {}\r\n  ): Promise<void> {\r\n    if (!Array.isArray(columns) || !columns.length) {\r\n      return this._errorHandler('#createTable', `'columns' must be an array`)\r\n    }\r\n\r\n    const query = this.sb.createTableIfNotExists(tableName, table => {\r\n      _.map(columns, column => {\r\n        if (_.isPlainObject(column)) {\r\n          if (!column.name) return\r\n          if (!column.type || !(column.type in table)) column.type = 'text'\r\n          let partial = table[column.type](column.name)\r\n\r\n          _.map(column, (attr, prop) => {\r\n            // name & type are handled above\r\n            if (prop === 'name' || prop === 'type') return\r\n            if (!(prop in partial)) return\r\n\r\n            // handle methods that take no arguments\r\n            switch (prop) {\r\n              case 'primary':\r\n              case 'notNull':\r\n              case 'notNullable':\r\n              case 'nullable':\r\n              case 'unsigned':\r\n                partial = partial[prop]()\r\n                break\r\n              default:\r\n                partial = partial[prop](attr)\r\n            }\r\n          })\r\n        } else if (_.isString(column)) {\r\n          table.text(column)\r\n        }\r\n      })\r\n\r\n      if ('compositeKey' in options) {\r\n        table.primary(options.compositeKey)\r\n      }\r\n    })\r\n\r\n    try {\r\n      await this.run(query)\r\n      return Promise.resolve()\r\n    } catch (e) {\r\n      return this._errorHandler(e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a table exists in the database\r\n   * @param {string} tableName\r\n   * @returns {Promise<boolean>}\r\n   */\r\n  async hasTable (\r\n    tableName: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      const res = await this.count('sqlite_master', 'name', {\r\n        name: tableName\r\n      })\r\n\r\n      return Promise.resolve(res > 0)\r\n    } catch (e) {\r\n      return this._errorHandler(e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Insert values into a table in the database.\r\n   *\r\n   * @param {string} tableName\r\n   * @param {Object} values\r\n   * @param {Object} [options={}]\r\n   * @param {string} [options.conflict]\r\n   *  An SQLite conflict type, one of: `fail`, `abort`, `ignore`,\r\n   *  `replace`, `rollback`.\r\n   * @returns {Promise<number>} The number of rows inserted\r\n   *\r\n   * @example\r\n   *\r\n   * db.insert('people', {\r\n   *   name: 'Bob',\r\n   *   age: 17\r\n   * })\r\n   *\r\n   * // insert or replace\r\n   * db.insert('people', {\r\n   *   name: 'Bob',\r\n   *   age: 17\r\n   * }, { conflict: 'replace' })\r\n   */\r\n  async insert (\r\n    tableName: string,\r\n    values: Object,\r\n    options?: { conflict?: string } = {}\r\n  ): Promise<number> {\r\n    if (!tableName || !_.isString(tableName)) {\r\n      return this._errorHandler('#insert', `'tableName' must be a string`)\r\n    }\r\n\r\n    let query = this.knex.table(tableName).insert(values)\r\n\r\n    // Knex doesn't have support for conflict clauses yet :(\r\n    if (options.conflict) {\r\n      const str = Trilogy._getConflictString(options.conflict)\r\n      query = query.toString().replace('insert into', `insert${str}into`)\r\n    }\r\n\r\n    try {\r\n      await this.run(query)\r\n      return Promise.resolve(this.db.getRowsModified())\r\n    } catch (e) {\r\n      return this._errorHandler(e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute a select query on the database. Allows overloading of arguments,\r\n   * ie. `table` is the only required argument. In this case, `columns`\r\n   * defaults to selecting all columns.\r\n   *\r\n   * @function\r\n   * @name select\r\n   * @memberOf Trilogy#\r\n   *\r\n   * @param {string} table\r\n   * @param {(string|Array)} [columns=['*']]\r\n   *  Defaults to selecting all columns.\r\n   * @param {(Object|Array|Function)} [where=['1', '=', '1']]\r\n   *  Defaults to no restriction on selection.\r\n   * @param {Object} [options={}]\r\n   * @param {boolean} [options.random=false]\r\n   *  Pass `true` to return records in random order.\r\n   * @returns {Promise<Array>}\r\n   *\r\n   * @example\r\n   *\r\n   * // select all records in the 'people' table\r\n   * db.select('people')\r\n   *\r\n   * // select just the 'age' and 'favColor' columns where name is 'Bob'\r\n   * db.select('people', ['age', 'favColor'], { name: 'Bob' })\r\n   *\r\n   * // select just 'name' where age is at least 18\r\n   * db.select('people', 'age', ['age', '>=', '18'])\r\n   */\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  async select (...params: Array<mixed>): Promise<Array<Object>> {\r\n    return (arify(v => {\r\n      v.str('table')\r\n       .obj('options', { random: false })\r\n       .add('columns', {\r\n         test: (value: mixed): boolean => _.isString(value) || Array.isArray(value),\r\n         description: 'a string or an array of strings',\r\n         defaultValue: ['*']\r\n       })\r\n       .add('where', {\r\n         test: (value: mixed): boolean => Trilogy._isValidWhere(value),\r\n         description: 'an object, array, or function',\r\n         defaultValue: ['1', '=', '1']\r\n       })\r\n\r\n      v.form('table', '?columns', '?where', '?options')\r\n    }, async (args: Object): * => {\r\n      const columns = Trilogy._sanitizeColumns(args.columns)\r\n\r\n      const partial = this.knex.column(columns).table(args.table)\r\n      let query = Trilogy._sanitizeWhere(args.where, partial)\r\n\r\n      if (args.options.random) {\r\n        query = query.orderByRaw('RANDOM()')\r\n      } else if (args.options.order) {\r\n        query = Trilogy._sanitizeOrder(args.options.order, partial)\r\n      }\r\n\r\n      try {\r\n        const result = await this.exec(query)\r\n        const res = Trilogy._parseResponse(result)\r\n        return Promise.resolve(res)\r\n      } catch (e) {\r\n        if (e.message.endsWith('of undefined')) {\r\n          // the value probably just doesn't exist\r\n          // resolve to undefined rather than reject\r\n          return Promise.resolve(undefined)\r\n        }\r\n        return this._errorHandler(e)\r\n      }\r\n    }))(...params)\r\n  }\r\n\r\n  /**\r\n   * Return the first row selected by the query. Allows overloading\r\n   * of arguments, ie. `table` is the only required argument. In this\r\n   * case, `columns` defaults to selecting all columns.\r\n   *\r\n   * @function\r\n   * @name first\r\n   * @memberOf Trilogy#\r\n   *\r\n   * @param {string} table\r\n   * @param {(string|Array)} [columns=['*']]\r\n   *  Defaults to selecting all columns.\r\n   * @param {(Object|Array|Function)} [where=['1', '=', '1']]\r\n   *  Defaults to no restriction on selection.\r\n   * @param {Object} [options={}]\r\n   * @param {boolean} [options.random=false]\r\n   *  Pass `true` to return a random record.\r\n   * @returns {Promise<Object>}\r\n   *\r\n   * @example\r\n   *\r\n   * // select the first record in 'people'\r\n   * db.first('people')\r\n   *\r\n   * // select a random record from 'people'\r\n   * // the second argument is a where clause but is always true for all records\r\n   * db.first('people', ['1', '=', '1'], { random: true })\r\n   *\r\n   * // NOTE:\r\n   * // even with overloading, in this case `where` needs to be provided if we\r\n   * // have an `options` object. this is because `where` could also be an object\r\n   * // so the function has no way to know which one you meant to provide.\r\n   */\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  async first (...params: Array<mixed>): Promise<Object> {\r\n    return (arify(v => {\r\n      v.str('table')\r\n       .obj('options', { random: false })\r\n       .add('columns', {\r\n         test: (value: mixed): boolean => Array.isArray(value) || _.isString(value),\r\n         description: 'a string or an array of strings',\r\n         defaultValue: ['*']\r\n       })\r\n       .add('where', {\r\n         test: (value: mixed): boolean => Trilogy._isValidWhere(value),\r\n         description: 'an object, array, or function',\r\n         defaultValue: ['1', '=', '1']\r\n       })\r\n\r\n      v.form('table', '?columns', '?where', '?options')\r\n    }, async (args: Object): * => {\r\n      const columns = Trilogy._sanitizeColumns(args.columns)\r\n\r\n      const partial = this.knex.table(args.table).first(columns)\r\n      let query = Trilogy._sanitizeWhere(args.where, partial)\r\n\r\n      if (args.options.random) {\r\n        query = query.orderByRaw('RANDOM()')\r\n      }\r\n\r\n      try {\r\n        const result = await this.exec(query)\r\n        const res = Trilogy._parseResponse(result)\r\n        return Promise.resolve(res[0])\r\n      } catch (e) {\r\n        if (e.message.endsWith('of undefined')) {\r\n          // the value probably just doesn't exist\r\n          // resolve to undefined rather than reject\r\n          return Promise.resolve(undefined)\r\n        }\r\n        return this._errorHandler(e)\r\n      }\r\n    }))(...params)\r\n  }\r\n\r\n  /**\r\n   * Retrieve the value at a specific row in a specific column.\r\n   * Allows function overloading, ie. `table` is the only required\r\n   * argument. In this case, `column` must be provided as dot- or\r\n   * bracket-notation syntax of `table.column` or `table[column]`.\r\n   *\r\n   * @function\r\n   * @name getValue\r\n   * @memberOf Trilogy#\r\n   *\r\n   * @param {string} table\r\n   * @param {string} [column]\r\n   *  If this argument is not explicitly provided, it must be\r\n   *  included as part of `tableName` using either dot- or\r\n   *  bracket-notation.\r\n   * @param {(Object|Array|Function)} [where=['1', '=', '1']]\r\n   *  Defaults to no restriction on selection.\r\n   * @returns {Promise<*>}\r\n   *\r\n   * @example\r\n   *\r\n   * db.getValue('people', 'age', { name: 'Bob' })\r\n   *\r\n   * // dot- or bracket-notation of table and column\r\n   * db.getValue('people.age', { name: 'Bob' })\r\n   * db.getValue('people[age]', { name: 'Bob' })\r\n   */\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  async getValue (...params: Array<mixed>): Promise<mixed> {\r\n    return (arify(v => {\r\n      v.str('table')\r\n       .str('column')\r\n       .add('where', {\r\n         test: (value: mixed): boolean => Trilogy._isValidWhere(value),\r\n         description: 'an object, array, or function',\r\n         defaultValue: ['1', '=', '1']\r\n       })\r\n\r\n      v.form('table', '?column', 'where')\r\n    }, async (args: Object): * => {\r\n      const [tbl, col] = Trilogy._parseTablePath(args.table, args.column)\r\n\r\n      if (!col) {\r\n        return this._errorHandler(constants.ERR_COL_MISSING)\r\n      }\r\n\r\n      const partial = this.knex.table(tbl).first(col)\r\n      const query = Trilogy._sanitizeWhere(args.where, partial)\r\n\r\n      try {\r\n        const result = await this.exec(query)\r\n        const res = Trilogy._parseResponse(result)\r\n        return Promise.resolve(res[0][col])\r\n      } catch (e) {\r\n        if (e.message.endsWith('of undefined')) {\r\n          // the value probably just doesn't exist\r\n          // resolve to undefined rather than reject\r\n          return Promise.resolve(undefined)\r\n        }\r\n        return this._errorHandler(e)\r\n      }\r\n    }))(...params)\r\n  }\r\n\r\n  /**\r\n   * Update rows in the database.\r\n   *\r\n   * @function\r\n   * @name update\r\n   * @memberOf Trilogy#\r\n   *\r\n   * @param {string} table\r\n   * @param {(Object|Array)} values\r\n   *  Must either be an object or a key / value array (length === 2)\r\n   * @param {(Object|Array|Function)} [where=['1', '=', '1']]\r\n   *  Defaults to no restriction on selection.\r\n   * @param {Object} [options={}]\r\n   * @param {string} [options.conflict]\r\n   *  An SQLite conflict type, one of: `fail`, `abort`, `ignore`,\r\n   *  `replace`, `rollback`.\r\n   * @returns {Promise<number>} The number of rows affected\r\n   *\r\n   * @example\r\n   *\r\n   * db.update('people', { age: 18 }, { name: 'Bob' })\r\n   */\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  async update (...params: Array<mixed>): Promise<number> {\r\n    return (arify(v => {\r\n      v.str('table')\r\n       .obj('options', {})\r\n       .add('values', {\r\n         test: (value: mixed): boolean => {\r\n           return (\r\n             _.isPlainObject(value) || (Array.isArray(value) && value.length === 2)\r\n           )\r\n         }\r\n       })\r\n       .add('where', {\r\n         test: (value: mixed): boolean => Trilogy._isValidWhere(value),\r\n         description: 'an object, array, or function',\r\n         defaultValue: ['1', '=', '1']\r\n       })\r\n\r\n      v.form('table', 'values', '?where', '?options')\r\n    }, async (args: Object): * => {\r\n      const partial = this.knex.table(args.table)\r\n      const update = _.isPlainObject(args.values)\r\n        ? partial.update(args.values)\r\n        : partial.update(...args.values)\r\n\r\n      let query = Trilogy._sanitizeWhere(args.where, update)\r\n\r\n      // Knex doesn't have support for conflict clauses yet :(\r\n      if (args.options.conflict) {\r\n        const str = Trilogy._getConflictString(args.options.conflict)\r\n        query = query.toString().replace('update', `update${str}`)\r\n      }\r\n\r\n      try {\r\n        await this.run(query)\r\n        return Promise.resolve(this.db.getRowsModified())\r\n      } catch (e) {\r\n        return this._errorHandler(e)\r\n      }\r\n    }))(...params)\r\n  }\r\n\r\n  /**\r\n   * Increment a value at `column` by a specified `amount`.\r\n   * Allows function overloading, ie. `table` is the only\r\n   * required argument. In that case, column must be provided\r\n   * as part of `table` using dot- or bracket-notation. This\r\n   * allows for a short-and-sweet syntax in the case you only\r\n   * want to increment by 1.\r\n   *\r\n   * @function\r\n   * @name increment\r\n   * @memberOf Trilogy#\r\n   *\r\n   * @param {string} table\r\n   * @param {string} [column]\r\n   *  If this argument is not explicitly provided, it must be\r\n   *  included as part of `tableName` using either dot- or\r\n   *  bracket-notation.\r\n   * @param {number} [amount=1]\r\n   * @param {(Object|Array|Function)} [where=['1', '=', '1']]\r\n   *  Defaults to no restriction on selection.\r\n   * @returns {Promise}\r\n   *\r\n   * @example\r\n   *\r\n   * db.increment('people', 'age', 1, { name: 'Bob' })\r\n   *\r\n   * // we can make that much sweeter :)\r\n   * db.increment('people.age', { name: 'Bob' })\r\n   */\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  async increment (...params: Array<mixed>): Promise<void> {\r\n    return (arify(v => {\r\n      v.str('table')\r\n       .str('column')\r\n       .num('amount', 1)\r\n       .add('where', {\r\n         test: (value: mixed): boolean => Trilogy._isValidWhere(value),\r\n         description: 'an object, array, or function',\r\n         defaultValue: ['1', '=', '1']\r\n       })\r\n\r\n      v.form('table', '?column', '?amount', '?where')\r\n    }, async (args: Object): * => {\r\n      const [tbl, col] = Trilogy._parseTablePath(args.table, args.column)\r\n\r\n      if (!col) {\r\n        return this._errorHandler(constants.ERR_COL_MISSING)\r\n      }\r\n\r\n      const partial = this.knex.table(tbl).increment(col, args.amount)\r\n      const query = Trilogy._sanitizeWhere(args.where, partial)\r\n\r\n      try {\r\n        await this.run(query)\r\n        return Promise.resolve()\r\n      } catch (e) {\r\n        return this._errorHandler(e)\r\n      }\r\n    }))(...params)\r\n  }\r\n\r\n  /**\r\n   * Decrement a value at `column` by a specified `amount`.\r\n   * Allows function overloading, ie. `table` is the only\r\n   * required argument. In that case, column must be provided\r\n   * as part of `table` using dot- or bracket-notation. This\r\n   * allows for a short-and-sweet syntax in the case you only\r\n   * want to decrement by 1.\r\n   *\r\n   * @function\r\n   * @name decrement\r\n   * @memberOf Trilogy#\r\n   *\r\n   * @param {string} table\r\n   * @param {string} [column]\r\n   *  If this argument is not explicitly provided, it must be\r\n   *  included as part of `tableName` using either dot- or\r\n   *  bracket-notation.\r\n   * @param {(Object|Array|Function)} [where=['1', '=', '1']]\r\n   *  Defaults to no restriction on selection.\r\n   * @param {boolean} allowNegative\r\n   *  Unless set to `true`, the value will not be allowed to go\r\n   *  below a value of `0`.\r\n   * @returns {Promise}\r\n   *\r\n   * db.decrement('people', 'age', 1, { name: 'Bob' })\r\n   *\r\n   * // we can make that much sweeter :)\r\n   * db.decrement('people.age', { name: 'Bob' })\r\n   */\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  async decrement (...params: Array<mixed>): Promise<void> {\r\n    return (arify(v => {\r\n      v.str('table')\r\n       .str('column')\r\n       .num('amount', 1)\r\n       .bln('allowNegative', false)\r\n       .add('where', {\r\n         test: (value: mixed): boolean => Trilogy._isValidWhere(value),\r\n         description: 'an object, array, or function',\r\n         defaultValue: ['1', '=', '1']\r\n       })\r\n\r\n      v.form('table', '?column', '?amount', '?where', '?allowNegative')\r\n    }, async (args: Object): * => {\r\n      const [tbl, col] = Trilogy._parseTablePath(args.table, args.column)\r\n\r\n      if (!col) {\r\n        return this._errorHandler(constants.ERR_COL_MISSING)\r\n      }\r\n\r\n      const partial = this.knex.table(tbl)\r\n      const rawStr = args.allowNegative\r\n        ? `${col} - ${args.amount}`\r\n        : `MAX(0, ${col} - ${args.amount})`\r\n      const updated = partial.update({ [col]: this.knex.raw(rawStr) })\r\n      const query = Trilogy._sanitizeWhere(args.where, updated)\r\n\r\n      try {\r\n        await this.run(query)\r\n        return Promise.resolve()\r\n      } catch (e) {\r\n        return this._errorHandler(e)\r\n      }\r\n    }))(...params)\r\n  }\r\n\r\n  /**\r\n   * Delete rows from a table. Allows deletion of all records in\r\n   * a table by passing only a table name.\r\n   *\r\n   * @function\r\n   * @name del\r\n   * @memberOf Trilogy#\r\n   *\r\n   * @param {string} table\r\n   * @param {(Object|Array|Function)} [where=['1','=','1']]\r\n   *  Defaults to no restriction on selection.\r\n   * @returns {Promise<number>} The number of rows deleted\r\n   *\r\n   * @example\r\n   *\r\n   * // delete all records from 'people'\r\n   * db.del('people')\r\n   *\r\n   * // delete only where age is under 21\r\n   * db.del('people', ['age', '<', '21'])\r\n   */\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  async del (...params: Array<mixed>): Promise<number> {\r\n    return (arify(v => {\r\n      v.str('table')\r\n       .add('where', {\r\n         test: (value: mixed): boolean => Trilogy._isValidWhere(value),\r\n         description: 'an object, array, or function',\r\n         defaultValue: ['1', '=', '1']\r\n       })\r\n\r\n      v.form('table', '?where')\r\n    }, async (args: Object): * => {\r\n      const partial = this.knex.table(args.table).del()\r\n      const query = Trilogy._sanitizeWhere(args.where, partial)\r\n\r\n      try {\r\n        await this.run(query)\r\n        return Promise.resolve(this.db.getRowsModified())\r\n      } catch (e) {\r\n        return this._errorHandler(e)\r\n      }\r\n    }))(...params)\r\n  }\r\n\r\n  /**\r\n   * Return the number of rows, matching a criteria if specified.\r\n   *\r\n   * @function\r\n   * @name count\r\n   * @memberOf Trilogy#\r\n   *\r\n   * @param {string} table\r\n   * @param {String} [column='*']\r\n   *  Defaults to selecting all columns.\r\n   * @param {(Object|Array|Function)} [where=['1','=','1']]\r\n   *  Defaults to no restriction on selection.\r\n   * @param {Object} [options={}]\r\n   * @param {boolean} [options.distinct=false]\r\n   *  Counts only unique values if `true`.\r\n   * @returns {Promise<number>} The number of rows (meeting criteria if supplied)\r\n   *\r\n   * @example\r\n   *\r\n   * // given we have this data in our 'people' table:\r\n   * // |  name   |   age   |\r\n   * // |  Bob    |   18    |\r\n   * // |  Dale   |   25    |\r\n   * // |  Harry  |   32    |\r\n   *\r\n   * db.count('people')\r\n   * // -> 3\r\n   *\r\n   * // given we have tables `people`, `places`, `things`, & `ideas`\r\n   * // thanks to function overloading we can do this\r\n   * // to count number of tables in the database:\r\n   *\r\n   * db.count()\r\n   * // -> 4\r\n   */\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  count (...params: Array<mixed>): Promise<number> {\r\n    return (arify(v => {\r\n      v.str('table', 'sqlite_master')\r\n       .str('column', '*')\r\n       .obj('options', { distinct: false })\r\n       .add('where', {\r\n         test: (value: mixed): boolean => Trilogy._isValidWhere(value),\r\n         description: 'an object, array, or function',\r\n         defaultValue: ['1', '=', '1']\r\n       })\r\n\r\n      v.form('?table', '?column', '?where', '?options')\r\n    }, (args: Object): * => {\r\n      let partial\r\n      if (args.options.distinct) {\r\n        partial = this.knex.table(args.table).countDistinct(`${args.column} as count`)\r\n      } else {\r\n        partial = this.knex.table(args.table).count(`${args.column} as count`)\r\n      }\r\n\r\n      const query = Trilogy._sanitizeWhere(args.where, partial).toString()\r\n\r\n      try {\r\n        const statement = this.db.prepare(query)\r\n        const res = statement.getAsObject({})\r\n\r\n        if (_.isPlainObject(res) && 'count' in res) {\r\n          return Promise.resolve(res.count)\r\n        } else {\r\n          return Promise.resolve(0)\r\n        }\r\n      } catch (e) {\r\n        return this._errorHandler(e)\r\n      }\r\n    }))(...params)\r\n  }\r\n\r\n  /**\r\n   * Execute arbitrary SQLite queries. You can either write your\r\n   * own queries as you would with typical SQLite, or you can build\r\n   * them with knex and use the knex `toString` method before passing\r\n   * it here.\r\n   *\r\n   * Pass `true` as the second argument to return the results, otherwise\r\n   * the query will be assumed to be execution only.\r\n   *\r\n   * @param {string} query\r\n   *  Any arbitrary SQLite query string\r\n   * @param {boolean} ret\r\n   *  Pass `true` to return the results of the query\r\n   * @returns {Promise<(Object|undefined)>}\r\n   */\r\n  async raw (\r\n    query: string,\r\n    ret?: boolean = false\r\n  ): Promise<Object | void> {\r\n    try {\r\n      const done = ret ? await this.exec(query) : await this.run(query)\r\n      return Promise.resolve(ret ? done : undefined)\r\n    } catch (e) {\r\n      return this._errorHandler(e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Exposes the Knex schema builder object\r\n   * @returns {Object}\r\n   *\r\n   * @see {@link Trilogy#raw} to run queries built with this\r\n   */\r\n  getSchemaBuilder (): Object {\r\n    /**\r\n     * @prop sb\r\n     * @type {Object}\r\n     * @memberOf this\r\n     */\r\n    return this.sb\r\n  }\r\n\r\n  /**\r\n   * Exposes the Knex query builder object\r\n   * @returns {Object}\r\n   *\r\n   * @see {@link Trilogy#raw} to run queries built with this\r\n   */\r\n  getQueryBuilder (): Object {\r\n    return this.knex\r\n  }\r\n\r\n  /**\r\n   * Build an 'on conflict' clause query component\r\n   * @param {string} conflict - the type of query to build\r\n   * @returns {string} query component\r\n   * @static\r\n   * @private\r\n   */\r\n  static _getConflictString (conflict: string): string {\r\n    switch (conflict.toLowerCase()) {\r\n      case 'fail': return ' or fail '\r\n      case 'abort': return ' or abort '\r\n      case 'ignore': return ' or ignore '\r\n      case 'replace': return ' or replace '\r\n      case 'rollback': return ' or rollback '\r\n      default: return ' '\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse an sql.js return value into a sane JS array\r\n   * @param {Array} contents\r\n   * @returns {Array}\r\n   * @static\r\n   * @private\r\n   */\r\n  static _parseResponse (contents: Array<Object>): Array<Object> {\r\n    if (contents.length) {\r\n      const columns = contents[0].columns\r\n      const values = contents[0].values\r\n      const results = []\r\n      for (let i = 0; i < values.length; i++) {\r\n        let line = {}\r\n        for (let j = 0; j < columns.length; j++) {\r\n          line[columns[j]] = values[i][j]\r\n        }\r\n        results.push(line)\r\n      }\r\n      return results\r\n    } else {\r\n      return []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check that a where argument is a valid type\r\n   * Valid types are: Object | Array | Function\r\n   * @param {*} where\r\n   * @returns {boolean}\r\n   * @static\r\n   * @private\r\n   */\r\n  static _isValidWhere (where: any): boolean {\r\n    if (_.isPlainObject(where)) return true\r\n\r\n    if (Array.isArray(where)) {\r\n      const len = where.length\r\n      return len === 2 || len === 3\r\n    }\r\n\r\n    return _.isFunction(where)\r\n  }\r\n\r\n  /**\r\n   * Normalize a columns argument to an Array\r\n   * Returns ['*'] if the input is not a string or Array\r\n   * This means it defaults to 'all columns'\r\n   * @param {*} columns\r\n   * @returns {Array}\r\n   * @static\r\n   * @private\r\n   */\r\n  static _sanitizeColumns (\r\n    columns: string | Array<string>\r\n  ): Array<string> {\r\n    if (Array.isArray(columns)) return columns\r\n    if (_.isString(columns)) return [columns]\r\n    return ['*']\r\n  }\r\n\r\n  /**\r\n   * Complete a where query component based on type\r\n   * Arrays are spread into arguments\r\n   * Functions get bound to the knex instance\r\n   * Objects are passed along as is\r\n   * @param {(Object|Array|Function)} where\r\n   * @param {Object} partial - the current knex query chain\r\n   * @returns {Object} a continued knex query chain\r\n   * @static\r\n   * @private\r\n   */\r\n  static _sanitizeWhere (where: Object | Array<string> | Function, partial: Object): Object {\r\n    if (Array.isArray(where)) {\r\n      return partial.where(...where)\r\n    } else if (_.isFunction(where)) {\r\n      return partial.where(where.bind(partial))\r\n    } else {\r\n      // it's an object\r\n      return partial.where(where)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Complete an 'order by' query component\r\n   * Arrays are spread into arguments\r\n   * Strings are passed along as is\r\n   * @param {(Array|string)} order\r\n   * @param {Object} partial - the current knex query chain\r\n   * @returns {Object} a continued knex query chain\r\n   * @private\r\n   */\r\n  static _sanitizeOrder (\r\n    order: Array<mixed> | string,\r\n    partial: Object\r\n  ): Object {\r\n    if (Array.isArray(order) && order.length === 2) {\r\n      return partial.orderBy(...order)\r\n    } else if (_.isString(order)) {\r\n      return partial.orderBy(order)\r\n    } else {\r\n      return partial\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse a dot-notated path into table, column, & row\r\n   * @param {string} table\r\n   * @param {string} column\r\n   * @param {string} row\r\n   * @returns {Array<string>}\r\n   * @private\r\n   */\r\n  static _parseTablePath (\r\n    table: string,\r\n    column: ?string,\r\n    row: ?string\r\n  ): Array<?string> {\r\n    if (table.includes('.')) {\r\n      const [top, inner, nested] = table.split('.')\r\n      return Trilogy._parseTablePath(top, inner, nested)\r\n    } else if (table.includes('[')) {\r\n      const opener = table.indexOf('[')\r\n      const closer = table.indexOf(']', opener)\r\n\r\n      const top = table.substr(0, opener)\r\n      const inner = table.slice(opener + 1, closer)\r\n\r\n      const rowIndex = top.length + inner.length + 2\r\n\r\n      let extra, nested\r\n      if (rowIndex < table.length) {\r\n        extra = table.slice(rowIndex + 1)\r\n        const rowCloser = extra.indexOf(']')\r\n        nested = extra.substr(0, rowCloser)\r\n      }\r\n\r\n      return Trilogy._parseTablePath(top, inner, nested)\r\n    } else {\r\n      return [table, column, row]\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize errors to `Error` objects. If `err` is a string,\r\n   * it is used as the method path, with `msg` as the message.\r\n   * If an `errorListener` function was provided in the constructor,\r\n   * it will be called with the resulting error.\r\n   *\r\n   * @param {(string|Error)} err\r\n   * @param {string} [msg]\r\n   * @returns {Promise<Error>} a rejected promise with the `Error` object\r\n   * @private\r\n   */\r\n  _errorHandler (\r\n    err: string | Error,\r\n    msg?: string = constants.ERR_UNKNOWN\r\n  ): Promise<?Error> {\r\n    let e\r\n    if (err instanceof Error) {\r\n      e = err\r\n    } else if (_.isString(err)) {\r\n      e = (arguments.length === 1)\r\n        ? new Error(`Trilogy :: ${err}`)\r\n        : new Error(`Trilogy${err} :: ${msg}`)\r\n    }\r\n\r\n    e.name = 'TrilogyError'\r\n\r\n    if (this.errorListener) {\r\n      this.errorListener(e)\r\n    }\r\n\r\n    return Promise.reject(e)\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,kBAAe;AACb,EAAA,oIADa;AAIb,EAAA,wIAJa;AAOb,EAAA;AAPa,EAAA,CAAf;;MCWqB;;AAQnB,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA,EAAA,mBACE,QADF,EAME;AAAA,EAAA,QAJA,IAIA,yDAJsB;AACpB,EAAA,eAAS,mBAAM,EADK;AAEpB,EAAA,qBAAe;AAFK,EAAA,KAItB;;AAAA,EAAA;;AACA,EAAA,QAAI,CAAC,QAAL,EAAe,MAAM,IAAI,KAAJ,CAAU,mDAAV,CAAN;;AAEf,EAAA,mBAAc,IAAd,EAAoB;AAClB,EAAA,wBADkB;AAElB,EAAA,UAAI,IAFc;AAGlB,EAAA,eAAS,EAAE,UAAF,CAAa,KAAK,OAAlB,IACL,KAAK,OADA,GAEL,YAAM,EALQ;AAMlB,EAAA,qBAAe,EAAE,UAAF,CAAa,KAAK,aAAlB,IACX,KAAK,aADM,GAEX;AARc,EAAA,KAApB;;AAWA,EAAA,SAAK,KAAL;AACD,EAAA;;AAED,EAAA;;;;;;;;8BAIS;AACP,EAAA,UAAI,QAAQ,MAAR,CAAe,KAAK,QAApB,CAAJ,EAAmC;AACjC,EAAA,YAAM,OAAO,QAAQ,IAAR,CAAa,KAAK,QAAlB,EAA4B,QAA5B,CAAb;AACA,EAAA,aAAK,EAAL,GAAU,IAAI,IAAI,QAAR,CAAiB,IAAjB,CAAV;AACD,EAAA,OAHD,MAGO;AACL,EAAA,aAAK,EAAL,GAAU,IAAI,IAAI,QAAR,EAAV;AACA,EAAA,aAAK,MAAL;AACD,EAAA;;AAED,EAAA,WAAK,IAAL,GAAY,KAAK,EAAE,QAAQ,QAAV,EAAoB,kBAAkB,IAAtC,EAAL,CAAZ;;AAEA,EAAA,WAAK,EAAL,GAAU,KAAK,IAAL,CAAU,MAApB;AACD,EAAA;;AAED,EAAA;;;;;;;+BAIU;AACR,EAAA,UAAI,CAAC,KAAK,EAAV,EAAc;AACZ,EAAA,aAAK,aAAL,CAAmB,UAAU,eAA7B;AACD,EAAA;;AAED,EAAA,UAAI;AACF,EAAA,YAAM,OAAO,KAAK,EAAL,CAAQ,MAAR,EAAb;AACA,EAAA,YAAM,SAAS,IAAI,MAAJ,CAAW,IAAX,CAAf;;AAEA,EAAA,gBAAQ,IAAR,CAAa,KAAK,QAAlB,EAA4B;AAC1B,EAAA,mBAAS,MADiB,EACT,MAAM;AADG,EAAA,SAA5B;AAGD,EAAA,OAPD,CAOE,OAAO,CAAP,EAAU;AACV,EAAA,aAAK,aAAL,CAAmB,CAAnB;AACD,EAAA;AACF,EAAA;;AAED,EAAA;;;;;;;;;;;;;;+EAUW;;;;;;;sBACJ,KAAK;;;;;mDACD,KAAK,aAAL,CAAmB,UAAU,eAA7B;;;;AAGT,EAAA,oBAAI,CAAC,EAAE,QAAF,CAAW,KAAX,CAAL,EAAwB,QAAQ,MAAM,QAAN,EAAR;AACxB,EAAA,qBAAK,OAAL,CAAa,KAAb;;mDAEO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAoB,MAApB,EAAkD;AACnE,EAAA,sBAAI;AACF,EAAA,0BAAK,EAAL,CAAQ,GAAR,CAAY,KAAZ;AACA,EAAA,0BAAK,MAAL;AACA,EAAA,2BAAO,SAAP;AACD,EAAA,mBAJD,CAIE,OAAO,CAAP,EAAU;AACV,EAAA,2BAAO,OAAO,CAAP,CAAP;AACD,EAAA;AACF,EAAA,iBARM;;;;;;;;;;;;;;;;;AAWT,EAAA;;;;;;;;;;;;;;iFAUY;;;;;;;sBACL,KAAK;;;;;oDACD,KAAK,aAAL,CAAmB,UAAU,eAA7B;;;;AAGT,EAAA,oBAAI,CAAC,EAAE,QAAF,CAAW,KAAX,CAAL,EAAwB,QAAQ,MAAM,QAAN,EAAR;AACxB,EAAA,qBAAK,OAAL,CAAa,KAAb;;oDAEO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAoB,MAApB,EAAkD;AACnE,EAAA,sBAAI;AACF,EAAA,wBAAM,MAAM,OAAK,EAAL,CAAQ,IAAR,CAAa,KAAb,CAAZ;AACA,EAAA,2BAAO,QAAQ,GAAR,CAAP;AACD,EAAA,mBAHD,CAGE,OAAO,CAAP,EAAU;AACV,EAAA,2BAAO,OAAO,CAAP,CAAP;AACD,EAAA;AACF,EAAA,iBAPM;;;;;;;;;;;;;;;;;AAUT,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iFA8CE,WACA;cACA,gEAAkB;;;;;;wBAEd,CAAC,MAAM,OAAN,CAAc,OAAd,CAAD,IAA2B,CAAC,QAAQ;;;;;oDAC/B,KAAK,aAAL,CAAmB,cAAnB;;;AAGH,EAAA,wBAAQ,KAAK,EAAL,CAAQ,sBAAR,CAA+B,SAA/B,EAA0C,iBAAS;AAC/D,EAAA,oBAAE,GAAF,CAAM,OAAN,EAAe,kBAAU;AACvB,EAAA,wBAAI,EAAE,aAAF,CAAgB,MAAhB,CAAJ,EAA6B;AAAA,EAAA;AAC3B,EAAA,4BAAI,CAAC,OAAO,IAAZ,EAAkB;AAAA,EAAA;AAAA,EAAA;AAClB,EAAA,4BAAI,CAAC,OAAO,IAAR,IAAgB,EAAE,OAAO,IAAP,IAAe,KAAjB,CAApB,EAA6C,OAAO,IAAP,GAAc,MAAd;AAC7C,EAAA,4BAAI,UAAU,MAAM,OAAO,IAAb,EAAmB,OAAO,IAA1B,CAAd;;AAEA,EAAA,0BAAE,GAAF,CAAM,MAAN,EAAc,UAAC,IAAD,EAAO,IAAP,EAAgB;AAC5B,EAAA;AACA,EAAA,8BAAI,SAAS,MAAT,IAAmB,SAAS,MAAhC,EAAwC;AACxC,EAAA,8BAAI,EAAE,QAAQ,OAAV,CAAJ,EAAwB;;AAExB,EAAA;AACA,EAAA,kCAAQ,IAAR;AACE,EAAA,iCAAK,SAAL;AACA,EAAA,iCAAK,SAAL;AACA,EAAA,iCAAK,aAAL;AACA,EAAA,iCAAK,UAAL;AACA,EAAA,iCAAK,UAAL;AACE,EAAA,wCAAU,QAAQ,IAAR,GAAV;AACA,EAAA;AACF,EAAA;AACE,EAAA,wCAAU,QAAQ,IAAR,EAAc,IAAd,CAAV;AATJ,EAAA;AAWD,EAAA,yBAjBD;AAL2B,EAAA;;AAAA,EAAA;AAuB5B,EAAA,qBAvBD,MAuBO,IAAI,EAAE,QAAF,CAAW,MAAX,CAAJ,EAAwB;AAC7B,EAAA,4BAAM,IAAN,CAAW,MAAX;AACD,EAAA;AACF,EAAA,mBA3BD;;AA6BA,EAAA,sBAAI,kBAAkB,OAAtB,EAA+B;AAC7B,EAAA,0BAAM,OAAN,CAAc,QAAQ,YAAtB;AACD,EAAA;AACF,EAAA,iBAjCa;;;yBAoCN,KAAK,GAAL,CAAS,KAAT;;;oDACC,QAAQ,OAAR;;;;;oDAEA,KAAK,aAAL;;;;;;;;;;;;;;;;;AAIX,EAAA;;;;;;;;;iFAME;;;;;;;;yBAGoB,KAAK,KAAL,CAAW,eAAX,EAA4B,MAA5B,EAAoC;AACpD,EAAA,wBAAM;AAD8C,EAAA,iBAApC;;;AAAZ,EAAA;oDAIC,QAAQ,OAAR,CAAgB,MAAM,CAAtB;;;;;oDAEA,KAAK,aAAL;;;;;;;;;;;;;;;;;AAIX,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;iFAyBE,WACA;cACA,gEAAkC;;;;;;wBAE9B,CAAC,SAAD,IAAc,CAAC,EAAE,QAAF,CAAW,SAAX;;;;;oDACV,KAAK,aAAL,CAAmB,SAAnB;;;AAGL,EAAA,wBAAQ,KAAK,IAAL,CAAU,KAAV,CAAgB,SAAhB,EAA2B,MAA3B,CAAkC,MAAlC;;AAEZ,EAAA;;AACA,EAAA,oBAAI,QAAQ,QAAZ,EAAsB;AACd,EAAA,qBADc,GACR,QAAQ,kBAAR,CAA2B,QAAQ,QAAnC,CADQ;;AAEpB,EAAA,0BAAQ,MAAM,QAAN,GAAiB,OAAjB,CAAyB,aAAzB,aAAiD,GAAjD,UAAR;AACD,EAAA;;;;yBAGO,KAAK,GAAL,CAAS,KAAT;;;oDACC,QAAQ,OAAR,CAAgB,KAAK,EAAL,CAAQ,eAAR,EAAhB;;;;;oDAEA,KAAK,aAAL;;;;;;;;;;;;;;;;;AAIX,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,EAAA;;;;;;;;;;;;;;;oDAIU,MAAM,aAAK;AACjB,EAAA,oBAAE,GAAF,CAAM,OAAN,EACE,GADF,CACM,SADN,EACiB,EAAE,QAAQ,KAAV,EADjB,EAEE,GAFF,CAEM,SAFN,EAEiB;AACd,EAAA,0BAAM,cAAC,KAAD;AAAA,EAAA,6BAA2B,EAAE,QAAF,CAAW,KAAX,KAAqB,MAAM,OAAN,CAAc,KAAd,CAAhD;AAAA,EAAA,qBADQ;AAEd,EAAA,iCAAa,iCAFC;AAGd,EAAA,kCAAc,CAAC,GAAD;AAHA,EAAA,mBAFjB,EAOE,GAPF,CAOM,OAPN,EAOe;AACZ,EAAA,0BAAM,cAAC,KAAD;AAAA,EAAA,6BAA2B,QAAQ,aAAR,CAAsB,KAAtB,CAA3B;AAAA,EAAA,qBADM;AAEZ,EAAA,iCAAa,+BAFD;AAGZ,EAAA,kCAAc,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX;AAHF,EAAA,mBAPf;;AAaA,EAAA,oBAAE,IAAF,CAAO,OAAP,EAAgB,UAAhB,EAA4B,QAA5B,EAAsC,UAAtC;AACD,EAAA,iBAfO;AAAA,EAAA,yEAeL,kBAAO,IAAP;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AACK,EAAA,mCADL,GACe,QAAQ,gBAAR,CAAyB,KAAK,OAA9B,CADf;AAGK,EAAA,mCAHL,GAGe,OAAK,IAAL,CAAU,MAAV,CAAiB,OAAjB,EAA0B,KAA1B,CAAgC,KAAK,KAArC,CAHf;AAIG,EAAA,iCAJH,GAIW,QAAQ,cAAR,CAAuB,KAAK,KAA5B,EAAmC,OAAnC,CAJX;;;AAMD,EAAA,gCAAI,KAAK,OAAL,CAAa,MAAjB,EAAyB;AACvB,EAAA,sCAAQ,MAAM,UAAN,CAAiB,UAAjB,CAAR;AACD,EAAA,6BAFD,MAEO,IAAI,KAAK,OAAL,CAAa,KAAjB,EAAwB;AAC7B,EAAA,sCAAQ,QAAQ,cAAR,CAAuB,KAAK,OAAL,CAAa,KAApC,EAA2C,OAA3C,CAAR;AACD,EAAA;;AAVA,EAAA;AAAA,EAAA;AAAA,EAAA,mCAasB,OAAK,IAAL,CAAU,KAAV,CAbtB;;AAAA,EAAA;AAaO,EAAA,kCAbP;AAcO,EAAA,+BAdP,GAca,QAAQ,cAAR,CAAuB,MAAvB,CAdb;AAAA,EAAA,8DAeQ,QAAQ,OAAR,CAAgB,GAAhB,CAfR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;;AAAA,EAAA,iCAiBK,aAAE,OAAF,CAAU,QAAV,CAAmB,cAAnB,CAjBL;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;;AAAA,EAAA,8DAoBU,QAAQ,OAAR,CAAgB,SAAhB,CApBV;;AAAA,EAAA;AAAA,EAAA,8DAsBQ,OAAK,aAAL,cAtBR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mBAfK;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,oBAAD;;;;;;;;;;;;;;;;;AA0CT,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,EAAA;;;;;;;;;;;;;;;oDAIU,MAAM,aAAK;AACjB,EAAA,oBAAE,GAAF,CAAM,OAAN,EACE,GADF,CACM,SADN,EACiB,EAAE,QAAQ,KAAV,EADjB,EAEE,GAFF,CAEM,SAFN,EAEiB;AACd,EAAA,0BAAM,cAAC,KAAD;AAAA,EAAA,6BAA2B,MAAM,OAAN,CAAc,KAAd,KAAwB,EAAE,QAAF,CAAW,KAAX,CAAnD;AAAA,EAAA,qBADQ;AAEd,EAAA,iCAAa,iCAFC;AAGd,EAAA,kCAAc,CAAC,GAAD;AAHA,EAAA,mBAFjB,EAOE,GAPF,CAOM,OAPN,EAOe;AACZ,EAAA,0BAAM,cAAC,KAAD;AAAA,EAAA,6BAA2B,QAAQ,aAAR,CAAsB,KAAtB,CAA3B;AAAA,EAAA,qBADM;AAEZ,EAAA,iCAAa,+BAFD;AAGZ,EAAA,kCAAc,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX;AAHF,EAAA,mBAPf;;AAaA,EAAA,oBAAE,IAAF,CAAO,OAAP,EAAgB,UAAhB,EAA4B,QAA5B,EAAsC,UAAtC;AACD,EAAA,iBAfO;AAAA,EAAA,yEAeL,kBAAO,IAAP;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AACK,EAAA,mCADL,GACe,QAAQ,gBAAR,CAAyB,KAAK,OAA9B,CADf;AAGK,EAAA,mCAHL,GAGe,OAAK,IAAL,CAAU,KAAV,CAAgB,KAAK,KAArB,EAA4B,KAA5B,CAAkC,OAAlC,CAHf;AAIG,EAAA,iCAJH,GAIW,QAAQ,cAAR,CAAuB,KAAK,KAA5B,EAAmC,OAAnC,CAJX;;;AAMD,EAAA,gCAAI,KAAK,OAAL,CAAa,MAAjB,EAAyB;AACvB,EAAA,sCAAQ,MAAM,UAAN,CAAiB,UAAjB,CAAR;AACD,EAAA;;AARA,EAAA;AAAA,EAAA;AAAA,EAAA,mCAWsB,OAAK,IAAL,CAAU,KAAV,CAXtB;;AAAA,EAAA;AAWO,EAAA,kCAXP;AAYO,EAAA,+BAZP,GAYa,QAAQ,cAAR,CAAuB,MAAvB,CAZb;AAAA,EAAA,8DAaQ,QAAQ,OAAR,CAAgB,IAAI,CAAJ,CAAhB,CAbR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;;AAAA,EAAA,iCAeK,aAAE,OAAF,CAAU,QAAV,CAAmB,cAAnB,CAfL;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;;AAAA,EAAA,8DAkBU,QAAQ,OAAR,CAAgB,SAAhB,CAlBV;;AAAA,EAAA;AAAA,EAAA,8DAoBQ,OAAK,aAAL,cApBR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mBAfK;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,oBAAD;;;;;;;;;;;;;;;;;AAwCT,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,EAAA;;;;;;;;;;;;;;;qDAIU,MAAM,aAAK;AACjB,EAAA,oBAAE,GAAF,CAAM,OAAN,EACE,GADF,CACM,QADN,EAEE,GAFF,CAEM,OAFN,EAEe;AACZ,EAAA,0BAAM,cAAC,KAAD;AAAA,EAAA,6BAA2B,QAAQ,aAAR,CAAsB,KAAtB,CAA3B;AAAA,EAAA,qBADM;AAEZ,EAAA,iCAAa,+BAFD;AAGZ,EAAA,kCAAc,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX;AAHF,EAAA,mBAFf;;AAQA,EAAA,oBAAE,IAAF,CAAO,OAAP,EAAgB,SAAhB,EAA2B,OAA3B;AACD,EAAA,iBAVO;AAAA,EAAA,0EAUL,mBAAO,IAAP;AAAA,EAAA;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,oDACkB,QAAQ,eAAR,CAAwB,KAAK,KAA7B,EAAoC,KAAK,MAAzC,CADlB;AAAA,EAAA;AACM,EAAA,+BADN;AACW,EAAA,+BADX;;AAAA,EAAA,gCAGI,GAHJ;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;;AAAA,EAAA,+DAIQ,OAAK,aAAL,CAAmB,UAAU,eAA7B,CAJR;;AAAA,EAAA;AAOK,EAAA,mCAPL,GAOe,OAAK,IAAL,CAAU,KAAV,CAAgB,GAAhB,EAAqB,KAArB,CAA2B,GAA3B,CAPf;AAQK,EAAA,iCARL,GAQa,QAAQ,cAAR,CAAuB,KAAK,KAA5B,EAAmC,OAAnC,CARb;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mCAWsB,OAAK,IAAL,CAAU,KAAV,CAXtB;;AAAA,EAAA;AAWO,EAAA,kCAXP;AAYO,EAAA,+BAZP,GAYa,QAAQ,cAAR,CAAuB,MAAvB,CAZb;AAAA,EAAA,+DAaQ,QAAQ,OAAR,CAAgB,IAAI,CAAJ,EAAO,GAAP,CAAhB,CAbR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;;AAAA,EAAA,iCAeK,cAAE,OAAF,CAAU,QAAV,CAAmB,cAAnB,CAfL;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;;AAAA,EAAA,+DAkBU,QAAQ,OAAR,CAAgB,SAAhB,CAlBV;;AAAA,EAAA;AAAA,EAAA,+DAoBQ,OAAK,aAAL,eApBR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mBAVK;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,oBAAD;;;;;;;;;;;;;;;;;AAmCT,EAAA;;;;;;;;;;;;;;;;;;;;;;;AAuBA,EAAA;;;;;;;;;;;;;;;qDAIU,MAAM,aAAK;AACjB,EAAA,oBAAE,GAAF,CAAM,OAAN,EACE,GADF,CACM,SADN,EACiB,EADjB,EAEE,GAFF,CAEM,QAFN,EAEgB;AACb,EAAA,0BAAM,cAAC,KAAD,EAA2B;AAC/B,EAAA,6BACE,EAAE,aAAF,CAAgB,KAAhB,KAA2B,MAAM,OAAN,CAAc,KAAd,KAAwB,MAAM,MAAN,KAAiB,CADtE;AAGD,EAAA;AALY,EAAA,mBAFhB,EASE,GATF,CASM,OATN,EASe;AACZ,EAAA,0BAAM,cAAC,KAAD;AAAA,EAAA,6BAA2B,QAAQ,aAAR,CAAsB,KAAtB,CAA3B;AAAA,EAAA,qBADM;AAEZ,EAAA,iCAAa,+BAFD;AAGZ,EAAA,kCAAc,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX;AAHF,EAAA,mBATf;;AAeA,EAAA,oBAAE,IAAF,CAAO,OAAP,EAAgB,QAAhB,EAA0B,QAA1B,EAAoC,UAApC;AACD,EAAA,iBAjBO;AAAA,EAAA,0EAiBL,mBAAO,IAAP;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AACK,EAAA,mCADL,GACe,OAAK,IAAL,CAAU,KAAV,CAAgB,KAAK,KAArB,CADf;AAEK,EAAA,kCAFL,GAEc,EAAE,aAAF,CAAgB,KAAK,MAArB,IACX,QAAQ,MAAR,CAAe,KAAK,MAApB,CADW,GAEX,QAAQ,MAAR,mCAAkB,KAAK,MAAvB,EAJH;AAMG,EAAA,iCANH,GAMW,QAAQ,cAAR,CAAuB,KAAK,KAA5B,EAAmC,MAAnC,CANX;;AAQD,EAAA;;AACA,EAAA,gCAAI,KAAK,OAAL,CAAa,QAAjB,EAA2B;AACnB,EAAA,iCADmB,GACb,QAAQ,kBAAR,CAA2B,KAAK,OAAL,CAAa,QAAxC,CADa;;AAEzB,EAAA,sCAAQ,MAAM,QAAN,GAAiB,OAAjB,CAAyB,QAAzB,aAA4C,GAA5C,CAAR;AACD,EAAA;;AAZA,EAAA;AAAA,EAAA;AAAA,EAAA,mCAeO,OAAK,GAAL,CAAS,KAAT,CAfP;;AAAA,EAAA;AAAA,EAAA,+DAgBQ,QAAQ,OAAR,CAAgB,OAAK,EAAL,CAAQ,eAAR,EAAhB,CAhBR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,+DAkBQ,OAAK,aAAL,eAlBR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mBAjBK;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,oBAAD;;;;;;;;;;;;;;;;;AAwCT,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,EAAA;;;;;;;;;;;;;;;qDAIU,MAAM,aAAK;AACjB,EAAA,oBAAE,GAAF,CAAM,OAAN,EACE,GADF,CACM,QADN,EAEE,GAFF,CAEM,QAFN,EAEgB,CAFhB,EAGE,GAHF,CAGM,OAHN,EAGe;AACZ,EAAA,0BAAM,cAAC,KAAD;AAAA,EAAA,6BAA2B,QAAQ,aAAR,CAAsB,KAAtB,CAA3B;AAAA,EAAA,qBADM;AAEZ,EAAA,iCAAa,+BAFD;AAGZ,EAAA,kCAAc,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX;AAHF,EAAA,mBAHf;;AASA,EAAA,oBAAE,IAAF,CAAO,OAAP,EAAgB,SAAhB,EAA2B,SAA3B,EAAsC,QAAtC;AACD,EAAA,iBAXO;AAAA,EAAA,0EAWL,mBAAO,IAAP;AAAA,EAAA;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,qDACkB,QAAQ,eAAR,CAAwB,KAAK,KAA7B,EAAoC,KAAK,MAAzC,CADlB;AAAA,EAAA;AACM,EAAA,+BADN;AACW,EAAA,+BADX;;AAAA,EAAA,gCAGI,GAHJ;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;;AAAA,EAAA,+DAIQ,OAAK,aAAL,CAAmB,UAAU,eAA7B,CAJR;;AAAA,EAAA;AAOK,EAAA,mCAPL,GAOe,OAAK,IAAL,CAAU,KAAV,CAAgB,GAAhB,EAAqB,SAArB,CAA+B,GAA/B,EAAoC,KAAK,MAAzC,CAPf;AAQK,EAAA,iCARL,GAQa,QAAQ,cAAR,CAAuB,KAAK,KAA5B,EAAmC,OAAnC,CARb;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mCAWO,OAAK,GAAL,CAAS,KAAT,CAXP;;AAAA,EAAA;AAAA,EAAA,+DAYQ,QAAQ,OAAR,EAZR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,+DAcQ,OAAK,aAAL,eAdR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mBAXK;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,oBAAD;;;;;;;;;;;;;;;;;AA8BT,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,EAAA;;;;;;;;;;;;;;;qDAIU,MAAM,aAAK;AACjB,EAAA,oBAAE,GAAF,CAAM,OAAN,EACE,GADF,CACM,QADN,EAEE,GAFF,CAEM,QAFN,EAEgB,CAFhB,EAGE,GAHF,CAGM,eAHN,EAGuB,KAHvB,EAIE,GAJF,CAIM,OAJN,EAIe;AACZ,EAAA,0BAAM,cAAC,KAAD;AAAA,EAAA,6BAA2B,QAAQ,aAAR,CAAsB,KAAtB,CAA3B;AAAA,EAAA,qBADM;AAEZ,EAAA,iCAAa,+BAFD;AAGZ,EAAA,kCAAc,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX;AAHF,EAAA,mBAJf;;AAUA,EAAA,oBAAE,IAAF,CAAO,OAAP,EAAgB,SAAhB,EAA2B,SAA3B,EAAsC,QAAtC,EAAgD,gBAAhD;AACD,EAAA,iBAZO;AAAA,EAAA,0EAYL,mBAAO,IAAP;AAAA,EAAA;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,qDACkB,QAAQ,eAAR,CAAwB,KAAK,KAA7B,EAAoC,KAAK,MAAzC,CADlB;AAAA,EAAA;AACM,EAAA,+BADN;AACW,EAAA,+BADX;;AAAA,EAAA,gCAGI,GAHJ;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;;AAAA,EAAA,+DAIQ,OAAK,aAAL,CAAmB,UAAU,eAA7B,CAJR;;AAAA,EAAA;AAOK,EAAA,mCAPL,GAOe,OAAK,IAAL,CAAU,KAAV,CAAgB,GAAhB,CAPf;AAQK,EAAA,kCARL,GAQc,KAAK,aAAL,GACR,GADQ,WACC,KAAK,MADN,eAED,GAFC,WAEQ,KAAK,MAFb,MARd;AAWK,EAAA,mCAXL,GAWe,QAAQ,MAAR,qBAAkB,GAAlB,EAAwB,OAAK,IAAL,CAAU,GAAV,CAAc,MAAd,CAAxB,EAXf;AAYK,EAAA,iCAZL,GAYa,QAAQ,cAAR,CAAuB,KAAK,KAA5B,EAAmC,OAAnC,CAZb;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mCAeO,OAAK,GAAL,CAAS,KAAT,CAfP;;AAAA,EAAA;AAAA,EAAA,+DAgBQ,QAAQ,OAAR,EAhBR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,+DAkBQ,OAAK,aAAL,eAlBR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mBAZK;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,oBAAD;;;;;;;;;;;;;;;;;AAmCT,EAAA;;;;;;;;;;;;;;;;;;;;;;AAsBA,EAAA;;;;;;;;;;;;;;;qDAIU,MAAM,aAAK;AACjB,EAAA,oBAAE,GAAF,CAAM,OAAN,EACE,GADF,CACM,OADN,EACe;AACZ,EAAA,0BAAM,cAAC,KAAD;AAAA,EAAA,6BAA2B,QAAQ,aAAR,CAAsB,KAAtB,CAA3B;AAAA,EAAA,qBADM;AAEZ,EAAA,iCAAa,+BAFD;AAGZ,EAAA,kCAAc,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX;AAHF,EAAA,mBADf;;AAOA,EAAA,oBAAE,IAAF,CAAO,OAAP,EAAgB,QAAhB;AACD,EAAA,iBATO;AAAA,EAAA,0EASL,mBAAO,IAAP;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AACK,EAAA,mCADL,GACe,OAAK,IAAL,CAAU,KAAV,CAAgB,KAAK,KAArB,EAA4B,GAA5B,EADf;AAEK,EAAA,iCAFL,GAEa,QAAQ,cAAR,CAAuB,KAAK,KAA5B,EAAmC,OAAnC,CAFb;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mCAKO,OAAK,GAAL,CAAS,KAAT,CALP;;AAAA,EAAA;AAAA,EAAA,+DAMQ,QAAQ,OAAR,CAAgB,OAAK,EAAL,CAAQ,eAAR,EAAhB,CANR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,+DAQQ,OAAK,aAAL,eARR;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,mBATK;;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA;AAAA,EAAA,oBAAD;;;;;;;;;;;;;;;;;AAsBT,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,EAAA;;;;;;8BAGiD;AAAA,EAAA;;AAC/C,EAAA,aAAQ,MAAM,aAAK;AACjB,EAAA,UAAE,GAAF,CAAM,OAAN,EAAe,eAAf,EACE,GADF,CACM,QADN,EACgB,GADhB,EAEE,GAFF,CAEM,SAFN,EAEiB,EAAE,UAAU,KAAZ,EAFjB,EAGE,GAHF,CAGM,OAHN,EAGe;AACZ,EAAA,gBAAM,cAAC,KAAD;AAAA,EAAA,mBAA2B,QAAQ,aAAR,CAAsB,KAAtB,CAA3B;AAAA,EAAA,WADM;AAEZ,EAAA,uBAAa,+BAFD;AAGZ,EAAA,wBAAc,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX;AAHF,EAAA,SAHf;;AASA,EAAA,UAAE,IAAF,CAAO,QAAP,EAAiB,SAAjB,EAA4B,QAA5B,EAAsC,UAAtC;AACD,EAAA,OAXO,EAWL,UAAC,IAAD,EAAqB;AACtB,EAAA,YAAI,gBAAJ;AACA,EAAA,YAAI,KAAK,OAAL,CAAa,QAAjB,EAA2B;AACzB,EAAA,oBAAU,QAAK,IAAL,CAAU,KAAV,CAAgB,KAAK,KAArB,EAA4B,aAA5B,CAA6C,KAAK,MAAlD,eAAV;AACD,EAAA,SAFD,MAEO;AACL,EAAA,oBAAU,QAAK,IAAL,CAAU,KAAV,CAAgB,KAAK,KAArB,EAA4B,KAA5B,CAAqC,KAAK,MAA1C,eAAV;AACD,EAAA;;AAED,EAAA,YAAM,QAAQ,QAAQ,cAAR,CAAuB,KAAK,KAA5B,EAAmC,OAAnC,EAA4C,QAA5C,EAAd;;AAEA,EAAA,YAAI;AACF,EAAA,cAAM,YAAY,QAAK,EAAL,CAAQ,OAAR,CAAgB,KAAhB,CAAlB;AACA,EAAA,cAAM,MAAM,UAAU,WAAV,CAAsB,EAAtB,CAAZ;;AAEA,EAAA,cAAI,EAAE,aAAF,CAAgB,GAAhB,KAAwB,WAAW,GAAvC,EAA4C;AAC1C,EAAA,mBAAO,QAAQ,OAAR,CAAgB,IAAI,KAApB,CAAP;AACD,EAAA,WAFD,MAEO;AACL,EAAA,mBAAO,QAAQ,OAAR,CAAgB,CAAhB,CAAP;AACD,EAAA;AACF,EAAA,SATD,CASE,OAAO,CAAP,EAAU;AACV,EAAA,iBAAO,QAAK,aAAL,CAAmB,CAAnB,CAAP;AACD,EAAA;AACF,EAAA,OAjCO,CAAD,4BAAP;AAkCD,EAAA;;AAED,EAAA;;;;;;;;;;;;;;;;;;;mFAgBE;cACA,4DAAgB;;;;;;;;uBAGD;;;;;;yBAAY,KAAK,IAAL,CAAU,KAAV;;;;;;;;;yBAAyB,KAAK,GAAL,CAAS,KAAT;;;;;;AAA5C,EAAA;qDACC,QAAQ,OAAR,CAAgB,MAAM,IAAN,GAAa,SAA7B;;;;;qDAEA,KAAK,aAAL;;;;;;;;;;;;;;;;;AAIX,EAAA;;;;;;;;;yCAM4B;AAC1B,EAAA;;;;;AAKA,EAAA,aAAO,KAAK,EAAZ;AACD,EAAA;;AAED,EAAA;;;;;;;;;wCAM2B;AACzB,EAAA,aAAO,KAAK,IAAZ;AACD,EAAA;;AAED,EAAA;;;;;;;;;;;;AAiKA,EAAA;;;;;;;;;;;oCAYE,KAEiB;AAAA,EAAA,UADjB,GACiB,yDADF,UAAU,WACR;;AACjB,EAAA,UAAI,UAAJ;AACA,EAAA,UAAI,eAAe,KAAnB,EAA0B;AACxB,EAAA,YAAI,GAAJ;AACD,EAAA,OAFD,MAEO,IAAI,EAAE,QAAF,CAAW,GAAX,CAAJ,EAAqB;AAC1B,EAAA,YAAK,UAAU,MAAV,KAAqB,CAAtB,GACA,IAAI,KAAJ,iBAAwB,GAAxB,CADA,GAEA,IAAI,KAAJ,aAAoB,GAApB,YAA8B,GAA9B,CAFJ;AAGD,EAAA;;AAED,EAAA,QAAE,IAAF,GAAS,cAAT;;AAEA,EAAA,UAAI,KAAK,aAAT,EAAwB;AACtB,EAAA,aAAK,aAAL,CAAmB,CAAnB;AACD,EAAA;;AAED,EAAA,aAAO,QAAQ,MAAR,CAAe,CAAf,CAAP;AACD,EAAA;;;yCAzL0B,UAA0B;AACnD,EAAA,cAAQ,SAAS,WAAT,EAAR;AACE,EAAA,aAAK,MAAL;AAAa,EAAA,iBAAO,WAAP;AACb,EAAA,aAAK,OAAL;AAAc,EAAA,iBAAO,YAAP;AACd,EAAA,aAAK,QAAL;AAAe,EAAA,iBAAO,aAAP;AACf,EAAA,aAAK,SAAL;AAAgB,EAAA,iBAAO,cAAP;AAChB,EAAA,aAAK,UAAL;AAAiB,EAAA,iBAAO,eAAP;AACjB,EAAA;AAAS,EAAA,iBAAO,GAAP;AANX,EAAA;AAQD,EAAA;;AAED,EAAA;;;;;;;;;;qCAOuB,UAAwC;AAC7D,EAAA,UAAI,SAAS,MAAb,EAAqB;AACnB,EAAA,YAAM,UAAU,SAAS,CAAT,EAAY,OAA5B;AACA,EAAA,YAAM,SAAS,SAAS,CAAT,EAAY,MAA3B;AACA,EAAA,YAAM,UAAU,EAAhB;AACA,EAAA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,GAAnC,EAAwC;AACtC,EAAA,cAAI,OAAO,EAAX;AACA,EAAA,eAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,MAA5B,EAAoC,GAApC,EAAyC;AACvC,EAAA,iBAAK,QAAQ,CAAR,CAAL,IAAmB,OAAO,CAAP,EAAU,CAAV,CAAnB;AACD,EAAA;AACD,EAAA,kBAAQ,IAAR,CAAa,IAAb;AACD,EAAA;AACD,EAAA,eAAO,OAAP;AACD,EAAA,OAZD,MAYO;AACL,EAAA,eAAO,EAAP;AACD,EAAA;AACF,EAAA;;AAED,EAAA;;;;;;;;;;;oCAQsB,OAAqB;AACzC,EAAA,UAAI,EAAE,aAAF,CAAgB,KAAhB,CAAJ,EAA4B,OAAO,IAAP;;AAE5B,EAAA,UAAI,MAAM,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,EAAA,YAAM,MAAM,MAAM,MAAlB;AACA,EAAA,eAAO,QAAQ,CAAR,IAAa,QAAQ,CAA5B;AACD,EAAA;;AAED,EAAA,aAAO,EAAE,UAAF,CAAa,KAAb,CAAP;AACD,EAAA;;AAED,EAAA;;;;;;;;;;;;uCAUE,SACe;AACf,EAAA,UAAI,MAAM,OAAN,CAAc,OAAd,CAAJ,EAA4B,OAAO,OAAP;AAC5B,EAAA,UAAI,EAAE,QAAF,CAAW,OAAX,CAAJ,EAAyB,OAAO,CAAC,OAAD,CAAP;AACzB,EAAA,aAAO,CAAC,GAAD,CAAP;AACD,EAAA;;AAED,EAAA;;;;;;;;;;;;;;qCAWuB,OAA0C,SAAyB;AACxF,EAAA,UAAI,MAAM,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,EAAA,eAAO,QAAQ,KAAR,mCAAiB,KAAjB,EAAP;AACD,EAAA,OAFD,MAEO,IAAI,EAAE,UAAF,CAAa,KAAb,CAAJ,EAAyB;AAC9B,EAAA,eAAO,QAAQ,KAAR,CAAc,MAAM,IAAN,CAAW,OAAX,CAAd,CAAP;AACD,EAAA,OAFM,MAEA;AACL,EAAA;AACA,EAAA,eAAO,QAAQ,KAAR,CAAc,KAAd,CAAP;AACD,EAAA;AACF,EAAA;;AAED,EAAA;;;;;;;;;;;;qCAUE,OACA,SACQ;AACR,EAAA,UAAI,MAAM,OAAN,CAAc,KAAd,KAAwB,MAAM,MAAN,KAAiB,CAA7C,EAAgD;AAC9C,EAAA,eAAO,QAAQ,OAAR,mCAAmB,KAAnB,EAAP;AACD,EAAA,OAFD,MAEO,IAAI,EAAE,QAAF,CAAW,KAAX,CAAJ,EAAuB;AAC5B,EAAA,eAAO,QAAQ,OAAR,CAAgB,KAAhB,CAAP;AACD,EAAA,OAFM,MAEA;AACL,EAAA,eAAO,OAAP;AACD,EAAA;AACF,EAAA;;AAED,EAAA;;;;;;;;;;;sCASE,OACA,QACA,KACgB;AAChB,EAAA,UAAI,MAAM,QAAN,CAAe,GAAf,CAAJ,EAAyB;AAAA,EAAA,2BACM,MAAM,KAAN,CAAY,GAAZ,CADN;;AAAA,EAAA;;AAAA,EAAA,YAChB,GADgB;AAAA,EAAA,YACX,KADW;AAAA,EAAA,YACJ,MADI;;AAEvB,EAAA,eAAO,QAAQ,eAAR,CAAwB,GAAxB,EAA6B,KAA7B,EAAoC,MAApC,CAAP;AACD,EAAA,OAHD,MAGO,IAAI,MAAM,QAAN,CAAe,GAAf,CAAJ,EAAyB;AAC9B,EAAA,YAAM,SAAS,MAAM,OAAN,CAAc,GAAd,CAAf;AACA,EAAA,YAAM,SAAS,MAAM,OAAN,CAAc,GAAd,EAAmB,MAAnB,CAAf;;AAEA,EAAA,YAAM,OAAM,MAAM,MAAN,CAAa,CAAb,EAAgB,MAAhB,CAAZ;AACA,EAAA,YAAM,SAAQ,MAAM,KAAN,CAAY,SAAS,CAArB,EAAwB,MAAxB,CAAd;;AAEA,EAAA,YAAM,WAAW,KAAI,MAAJ,GAAa,OAAM,MAAnB,GAA4B,CAA7C;;AAEA,EAAA,YAAI,cAAJ;AAAA,EAAA,YAAW,gBAAX;AACA,EAAA,YAAI,WAAW,MAAM,MAArB,EAA6B;AAC3B,EAAA,kBAAQ,MAAM,KAAN,CAAY,WAAW,CAAvB,CAAR;AACA,EAAA,cAAM,YAAY,MAAM,OAAN,CAAc,GAAd,CAAlB;AACA,EAAA,oBAAS,MAAM,MAAN,CAAa,CAAb,EAAgB,SAAhB,CAAT;AACD,EAAA;;AAED,EAAA,eAAO,QAAQ,eAAR,CAAwB,IAAxB,EAA6B,MAA7B,EAAoC,OAApC,CAAP;AACD,EAAA,OAjBM,MAiBA;AACL,EAAA,eAAO,CAAC,KAAD,EAAQ,MAAR,EAAgB,GAAhB,CAAP;AACD,EAAA;AACF,EAAA;;;;;;;;"}